---
title: 浏览器
date: 2023-09-06 15:25:39
tags: ["browser", "review"]
index_img: /img/event-loop-index.jpg
banner_img: /img/event-loop-banner.png
---

## 线程和进程

1. 进程中的任一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
4. 进程之间的内容相互隔离

## 多进程架构浏览器

{% asset_img multi-frame.webp multi-frame %}

- 浏览器进程：主要负责界面显示，用户交互，子进程管理，同时提供存储等功能
- 渲染进程：核心任务是将 HTML，CSS 和 js 转换为用户可以与之交互的网页，排版引擎 Blink 和 js 引擎 V8 都是运行在此进程中。chrome 会为每个 tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程：网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。
- 网络进程：主要负责页面的网络资源加载。
- 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

> 缺点
>
> - 更高的资源占用。因为每个进程都会包含公共进出结构的副本
> - 更复杂的体系结构

## 浏览器渲染

从输入 URL 到页面展示完整流程示意图
{% asset_img browser-render.webp browser-render %}

大致过程如下：

- 首先用户从浏览器进程里输入请求信息
- 然后网络进程发起 URL 请求
- 服务器响应请求后，浏览器进程就又要开始准备渲染进程了
- 渲染进程准备好之后，需要现象需要先向渲染进程提交页面数据，我们称之为提交文档阶段
- 渲染进程接收完文档信息后，便开始解析页面和加载子资源，完成页面渲染

### 从输入 URL 到页面展示

#### 用户输入

当用户在地址栏输入一个关键字时，地址栏会判断输入的关键字是搜索内容还是请求的 URL

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL
- 如果判断输入内容符合 URL 规则，那么地址栏会根据规则，将内容加上协议，合成完整的 URL

此时浏览器标签栏会进入加载状态，页面内容需要等待提交文档阶段时才会被替换

### URL 请求过程

接下来，便进入了页面资源请求过程。这时浏览器进程会通过进程间通信 IPC 把 URL 请求发送至网络进程，网络进程收到请求后，会在这里发起真正 的 URL 请求流程

具体流程如下：

- 首先**网络进程**会查找本地缓存是否缓存了资源。如果有缓存资源，那么直接返回资源给浏览器进程
- 如果在缓存中没有找到资源，那么直接进入网络请求流程，这请求第一步是进行 DNS 解析，以获取请求域名和 ip 如果协议是 https，还会建立 TLS 连接。
- 接下来就是利用 IP 和服务器建立 TCP 连接。连接建立之后，浏览器会构建请求行，请求头等信息，并把和该域名相关的 cookie 等数据附加请求头中，然后向服务器发送构建的请求信息。
- 服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行，响应头和响应体等信息），并发给网络进程。等网络进程接收到了响应行和响应头之后，就解析响应头的内容。

（1）**重定向**
在收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或 302，那么说明服务器需要浏览器重定向到其他 URL，这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始。

（2） **相应数据类型处理**
在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候会是下载类型，有时是正常的 HTML 页面，那么浏览器如何区分：

#### content-type

它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

如果 content-type 值为 application/octet-stream,显示的是字节流类型，浏览器会将请求提交给下载管理器，同时 URL 请求的导航流程就到此结束。

如果是 html 类型，接下来准备渲染进程了。

### 准备渲染进程

默认情况下，chrome 会为每个页面分配一个渲染进程，但也有例外，多个页面直接运行在一个渲染进程下面。只有属于同一个站点下的域名会使用同个渲染进程。

我们将“同一站点”定义为根域名（例如，baidu.com）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口。

```bash
# 以下都属于同一个站点
https://www.baidu.com
https://map.baidu.com
https://www.baidu.com:8080
```

Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

打开一个新页面采用的渲染进程策略就是：

通常情况下，打开新的页面都会使用单独的渲染进程；

- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；
- 如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

### 提交文档

这里的“文档”是指 URL 请求的响应体数据。

> 提交文档的消息由浏览器进程发出，渲染进程收到提交文档消息后，会和网络进程建立传输数据的管道。
> 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
> 浏览器进程在收到“确认提交”消息后，会更新浏览器界面状态，包含了安全状态，地址栏 URL，前进后退的历史状态，并更新 web 页面。

到这里导航的流程走完了，之后进入渲染阶段。

### 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载，渲染的流水线分为几个阶段：构建 DOM 树，样式计算，布局阶段，分层，绘制，分块，光栅化和合成。

#### 构建 DOM 树

输入：HTML
输出：DOM 树

#### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成

1. 把 css 转为浏览器能理解的结构

渲染引擎在收到 css 文本后，会执行一个转换操作，将 css 文本转换为浏览器可以理解的结构--styleSheets，该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。

2. 转换样式表中的属性值，使其标准化

将 css 属性值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

3. 计算出 DOM 树中每个节点的具体样式

样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 **CSS 的继承**和**层叠**两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 `ComputedStyle` 的结构内

#### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

chrome 在布局阶段需要完成两个任务：创建布局树和布局计算.

1. 布局树的构造过程：

{% asset_img layout-dom.webp layout-dom %}

为了构建布局树，浏览器大体上完成了下面这些工作

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容。

2. 布局计算

现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了

在执行布局操作的时候，会把布局计算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容。

#### 分层

因为页面中有很多复杂效果，如一些复杂的 3D 变换，页面滚动，或者使用 z-index 做 z 轴排序，为了更加方便的实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。正是这些图层叠加在一起构成了最终的页面图像。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

满足下面两点中任意一点的元素就可以被提升为单独的一个图层

1. 拥有层叠上下文属性的元素会被提升位单独的一层
   页面是一个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。

**明确定位属性的元素，定义透明属性的元素，使用 CSS 滤镜的元素，都有层叠上下文属性。**

2. 需要剪裁的地方也会被创建为图层

div 里面的文字内容多，超出 div 所显示的区域，就会发生剪裁，出现这种裁减情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

#### 图层绘制

渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。

#### 栅格化操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由**渲染引擎**中的**合成线程**来完成。

{% asset_img raster.webp raster %}

如上图所示：当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程。

**合成线程的工作原理**

合成线程会将图层划分为图块，这些图块大小通常是 256x256 或者 512x512

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图，而**图块是栅格化执行的最小单位**。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。运行方式如下：
{% asset_img raster-operation.webp raster-operation %}

通常栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

{% asset_img raster-gpu.webp gpu %}

渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

#### 合成和显示

一旦所有的图块都被光栅化，合成线程就会生成一个绘制图块的命令（DrawQuad），然后将该命令交给浏览器进程。

浏览器进程里有一个 viz 组件，用来接受合成线程发来的 DrawQuad 命令，然后根据该命令，将其页面内容绘制在内存中，最后再将内存显示在屏幕上。

#### 总结

整个渲染流程如下：

{% asset_img render.webp 渲染流程 %}

{% asset_img relayout.webp relayout%}

结合上图，一个完整的渲染流程大致可总结为如下

- 渲染进程将 HTML 内容转换为浏览器能够读懂的 DOM 树结构
- 渲染引擎将 css 样式表转化为浏览器可以理解的 stylesheets，计算出 DOM 节点的样式
- 创建布局树，并计算元素的布局信息
- 对布局树进行分层，并生成分层树
- 为每个图层生成绘制列表，并将其提交到合成线程
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换为位图
- 合成线程发送绘制图块命令到浏览器进程
- 浏览器进程根据命令信息生成页面，并显示到显示器上

### 重排 (更新了元素的几何属性)

{% asset_img relayout.webp 重排 %}

通过 css、js 修改元素的几何位置属性，例如改变元素的宽度，高度，浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排是要更新完整的渲染流水线，所以开销也大。

### 重绘 (更新了元素的绘制属性)

{% asset_img repaint.webp 重绘 %}

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘.

相较于重排，重绘省去了布局和分层阶段，所以执行效率会比重排操作更高一些

### 直接合成阶段

渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

{% asset_img compute.webp compute %}

在使用了 css 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在主线程上执行合成动画操作，因为是在非主线程上来合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段。

### 实践中优化减少重排重绘的方法

- 触发 repaint，reflow 的操作尽量放在一起，避免出现多次重排
- 通过虚拟 dom 层计算出操作总的差异，一起提交给浏览器。之前还用`createdocumentfragment`来汇总 append 的 dom,来减少触发重排重绘次数。

## 块级作用域

当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独区域中，合格区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，他们是独立存在的。

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用块内部的变量压到栈顶，当作用域执行完成后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。

当执行到作用域块中的 console.log(a)时，就需要在词法环境和变量环境中查找变量 a 的值，具体查找方式是：沿着词法环境的栈顶乡下查询，如果在词法环境中的某个人块中找到了，就会直接返回给 js 引擎，如果没有找到，就会继续在变量环境中查找

{% asset_img exclusive.webp exclusive %}

**块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的**。通过这两者结合，js 引擎也就同时支持了变量提升和块级作用域了。

## 词法作用域

> 词法作用域是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它能够预测代码在执行过程中如何查找标识符。

js 的作用域链由词法作用域决定的，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系

块级作用域中，当要查找一个在当前作用域中不存在的变量，就会按照作用域链在其他作用域中查找该变量。

## 闭包

定义：在 js 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包.

闭包中 js 引擎会沿着**当前执行上下文->闭包函数->全局执行上下文**顺序来查找变量

### 闭包是如何回收的

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## 垃圾回收

### 调用栈中的数据

当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP（一个记录当前执行状态的指针） 来销毁该函数保存在栈中的执行上下文。

### 堆中数据

#### 代际假说（The Generational Hypothesis）和分代收集

代际假说两大特点：

- 大部分对象在内存中存在的时间很短，很多对象已经分配内存，很快就变得不可访问
- 不死的对象，会活得很久

在 V8 中会把**堆分为*新生代*和*老生代*两个区域**，**新生代中存放的就是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生区只支持 1~8M 的容量，而老生区支持的容量就很大。V8 分别使用两个不同的垃圾回收器，

- 副垃圾回收器，主要负责新生代的垃圾回收
- 主垃圾回收器，主要负责老生代的垃圾回收

#### 垃圾回收器的工作流程

1. 标记空间中的活动对象和非活动对象。活动对象是还在使用的对象，非活动对象是可以进行垃圾回收的对象
2. 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象
3. 做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

#### 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收。通常情况下，大多数小的对象都会被分配在新生区，垃圾回收比较频繁。

新生代中用 Scavenge 算法来处理。Scavenge 算法：是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：
{% asset_img scavenge.png scavenge %}

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时还会把这些对象有序的排列起来，所以这个复制过程也完成了内存整理操作，复制后空闲区域内就没有内存碎片了

完成复制后，对象区域与空闲区域就进行角色翻转，也就是原来的对象区域变为空闲区域，原来的空闲区域变成对象区域，这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，所以新生区的空间一般设置的比较小

因为新生区空间不大，很容易被存活的对象装满了整个区域，为了解决这个问题，js 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然存货的对象，会被移动到老生区

#### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收

除了新生区晋升的对象，一些大的对象会直接被分配到老生区。因此老生区的对象有两个特点，一个是占用空间大，一个是对象存活时间长

主垃圾回收器是采用 **标记-清除（mark-sweep）算法**进行垃圾回收

首先是标记过程阶段，标记阶段是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

接下来是垃圾的清楚过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程。

上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

{% asset_img mark-compact.png mark-compact %}

### 全停顿

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：

{% asset_img incremental-mark.png incremental-mark %}

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了

## XMLHttpRequest 运行机制

{% asset_img xmlhttprequest.png xmlhttprequest %}

## 宏任务和微任务

### 宏任务

### 微任务

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

主要两种形式：

- 把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数
- 执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。

#### 产生微任务的方式

1. 使用 `MutationObserver` 监控某个 DOM 节点，然后再通过 js 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。

2. 使用 `Promise`，当调用 Promise.resolve()或者 Promise.reject()的时候，也会产生微任务

#### 微任务队列的执行时机

通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

如果在执行微任务的过程，产生了新的微任务，同样会将该微任务添加到微任务列表中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前宏任务中继续执行。

{% asset_img mircotask.png mirco %}

该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。

在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文

### MutationObserver 执行机制

Mutation 将相应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。

在每次 DOM 节点发生变化时，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了

综上所述， MutationObserver 采用了“异步 + 微任务”的策略。

- 通过异步操作解决了同步操作的性能问题
- 通过微任务解决了实时性问题

## async/await 底层实现机制

### 生成器 && 协程

生成器函数是一个带星号的函数，可以暂停执行和回复执行的

```js
function* genDemo() {
  console.log(" 开始执行第一段 ");
  yield "generator 2";

  console.log(" 开始执行第二段 ");
  yield "generator 2";

  console.log(" 开始执行第三段 ");
  yield "generator 2";

  console.log(" 执行结束 ");
  return "generator 2";
}

console.log("main 0");
let gen = genDemo();
console.log(gen.next().value);
console.log("main 1");
console.log(gen.next().value);
console.log("main 2");
console.log(gen.next().value);
console.log("main 3");
console.log(gen.next().value);
console.log("main 4");
```

生成器函数具体使用方式：

- 在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 js 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。
- 外部函数可以通过 next 方法恢复函数的执行

#### 协程

协程是一种比线程更轻量级的存在，可以把协程看成跑在线程上的任务，一个线程上可以有多个协程，但是在线程上同时只能执行一个协程。通常如果从 a 协程启动 b 协程，我们把 a 协程称为 b 协程的父协程。

协程不是被操作系统内核所管理的，而完全由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了提升，不会产生切换。

协程执行过程图：

{% asset_img coroutine.png coroutine %}

协程的四点规则：

- 通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后 gen 协程并没有立即执行
- 要让 gen 协程执行，需要调用 gen.next
- 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程
- 如果协程在执行期间遇到了 return 关键字，那么 js 引擎就会结束当前协程，并将 return 后面的内容返回给父协程

gen 协程和父协程是在主协程上交互执行的，并不是并发执行的，他们之间的切换是通过 yield 和 gen.next 来配合完成

当在 gen 协程中调用了 yield 方法时，js 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，js 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息

父协程和 gen 协程的切换调用栈
{% asset_img switch-stack.png switch-stack %}

在 js 中，生成器是协程的一种实现方式。

### async/await 原理

async/await 技术背后的就是 Promise 和生成器应用，往底层了说就是微任务和协程

**async**

async 是一个通过异步执行并隐式返回 Promise 作为结果的函数

**await**

async/await 执行流程图

{% asset_img async-await.png async-await %}

```js
async function foo() {
  console.log(1);
  let a = await 100;
  console.log(a);
  console.log(2);
}
console.log(0);
foo();
console.log(3);

// 0 1 3 100 2
```

首先执行 console.log(0);，打印 0
接着执行 foo 函数，由于 foo 被 async 标记过，所以当进入该函数的时候，js 会保存当前的调用栈信息，然后执行 console.log(1);
接下来执行到 await 100 的时候，会默认创建一个 Promise 对象：

```js
let promise_ = new Promise((resolve, reject) {
  resolve(100)
})
```

在这个 promise*对象创建过程中，js 引擎会将该任务提交给微任务队列
然后 js 引擎会暂停当前的协程执行，将主线程的控制权交给父协程执行，同时会将 promise*对象返回给父协程

主线程的控制权已经交给了父协程，父协程需要调用 promise\_.then 来监控 promise 状态的改变

接下来继续执行父协程的流程，这里执行 console.log(3)。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，里面存在 resolve(100)待执行，执行到这里的时候，会触发 promise\_.then 中的回调函数

```js
promise_.then((value) => {
  // 回调函数被激活后，将主线程控制权交给foo协程，并将value传给协程
});
```

foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。

## 页面性能分析

### 优化时间线上耗时项

1. 排队时间过久

排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，这种方案称为域名分片技术。还可以将站点升级到 http2，因为 http2 已经没有每个域名最多维护 6 个 tcp 连接的限制了。

2. 第一字节时间（TTFB）时间过久

- 服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。
- 网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。
- 发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。

3. Content Download 时间过久

如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致。这时候就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。

### Dom 树构建

JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。

Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，

async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 `DOMContentLoaded` 事件之前执行。

### CSSDom 树构建

{% asset_img css-render.png css-render %}

渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。

#### 白屏优化

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的的注释，压缩 js 文件
- 将一些不需要再解析 HTML 阶段使用的 js 标记上 async 或者 defer
- 对于大的 css 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 css 文件，这样只有在特定的场景下才会加载特定的 css 文件

### 利用分层技术优化

添加 will-change 的 css 属性，提前告诉渲染引擎将要做一些变化，渲染引擎会将该元素单独实现一帧，等变化发生时，渲染引擎会通过合成线程直接去处理变化，这些变换并没有涉及到主线程，这样就大大提升了渲染效率。

如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。

### 页面性能

1. 减少 js 脚本执行时间

- 将一次执行的函数分解为多个任务，使得每次执行时间不要过久
- 采用 web workers

2. 避免强制同步布局

强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中

3. 避免布局抖动

布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。

尽量不要在修改 DOM 结构时再去查询一些相关值。

4. 合理利用 css 合成动画

合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。

另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。

5. 避免频繁地垃圾回收

我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。

所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。

## webComponent

要使用 webComponent，需要实现下面三个步骤

1. 首先使用 template 属性来创建模板。
2. 其次 我们需要创建一个类，在该类的构造函数中要完成 3 件事：

- 查找模板内容
- 创建影子 Dom
- 再将模板添加到影子 DOM 上

影子 DOM 的作用是将模板中的内容与全局 DOM 和 css 进行隔离，这样我们就可以实现元素和样式的私有化。在创建好封影子 DOM 的类之后，我们就可以使用 customElements.define 来自定义元素了。影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。

3. 最后像使用 HTML 元素一样使用该元素

## 浏览器网络

### http1.1 优化

- 增加了持久连接
- 浏览器为每个域名最多同时维护 6 个 TCP 连接
- 使用 CDN 的实现名片机制

### http1.1 主要问题

http1.1 对带宽的利用率并不理想。带宽是指每秒最大能发送或者接收的字节数。每秒能发送的最大字节数称为上行带宽，没笑能够接收的最大字节数成为下行带宽。

之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。

原因如下：

1. TCP 的慢启动
   一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

   慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。

   而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。

2. 同时开启了多条 TCP 连接，那么这么多连接会竞争固定的带宽
   因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。

3. http1.1 队头阻塞问题
   在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

### http2 的多路复用

HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。

HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。

{% asset_img http2.png http2 %}

http2 添加了一个二进制分帧层，如下 HTTP2 请求和接收过程

- 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
- 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
- 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
  然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
  同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
- 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求

### http2 其他特性

1. 可以设置请求的优先级
   HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。

2. 服务器推送
   除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。

3. 头部压缩
   HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。

## 同源策略

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。

同源策略主要表现在 DOM，web 数据和网络三个层面

- DOM 层面。同源策略限制了来自不同源的 js 脚本对当前 DOM 对象读和写的操作
- 数据层面。同源策略限制了不同源站点读取当前站点的 Cookie，indexDB，localStorage 等数据。
- 网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

## 面试回答

渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构

渲染引擎将 CSS 样式表转化为浏览器理解的 styleSheets，计算出 DOM 节点的样式

创建布局树，并计算元素的布局信息

对布局树进行分层，并生成分层树

为每个图层绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换为位图

合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上
