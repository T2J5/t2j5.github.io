---
title: 浏览器缓存
date: 2023-09-04 21:16:58
tags: ["review", "browser", "http"]
index_img: /img/browser_index.jpg
banner_img: /img/browser_banner.jpg
---

浏览器缓存分为`强缓存`和`协商缓存`。

先从 <b>http header</b> 判断是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器。

当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 <b>request header</b> 验证这个资源是否命中协商缓存，称为 `http 再验证`。如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源。

强缓存和协商缓存的共同之处在于，如果命中换成，服务器都不会返回资源；

区别是强缓存不发送请求到服务器，而协商缓存会。

当协商缓存也没命中时，服务器就会讲资源发送到客户端

当按下 <font color="#54FF9F">ctrl+F5</font> 时，跳过强缓存和协商缓存，直接从服务器加载资源

当 <font color="#54FF9F">F5</font> 刷新网页时，跳过强缓存，但是会检查协商缓存

---

## 强缓存

### 强缓存的规则

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是`Expires`和`Cache-Control`，其中`Cache-Control`优先级比`Expires`高。

### `Expires`

该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间。值为服务器返回改请求结果缓存的到期时间，即再次发起请求时，如果客户端的时间小于 `Expires` 的值时，直接使用缓存结果。

### `Cache-Control:max-age`

该字段是 http1.1 的规范，作为替换 `expires`。强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期。

取值为：

- public 所有内容都被换成（客户端和代理服务器都可以缓存）
- private 所有内容只有客户端可以缓存，`Cache-control` 默认取值
- no-cache 客户端缓存内容 但是是否使用缓存则需要经过协商缓存来验证决定
- no-store 所有内容都不会缓存，即不使用强制缓存也不使用协商缓存
- max-age=xxx 缓存内容将在 xxx 秒后失效

> 浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？

Status 状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size 值则代表该缓存存放的位置，分别为 `from memory cache` 和 `from disk cache`。

`from memory cache` 代表使用内存中的缓存，`from disk cache` 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –> disk。

内存缓存(from memory cache)和硬盘缓存(from disk cache)差异：

内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：

快速读取： 内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以便下次运行使用时快速读取

时效性： 一旦进程关闭，该进程的内存就会被清空

硬盘缓存： 硬盘缓存是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 IO 操作，然后重新解析改内存内容，速度慢。

在浏览器中，浏览器会在 `js` 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 `css` 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。

> last-modified 缺点

`Last-Modified` 也有它的缺点，比如修改时间是 GMT 时间，只能精确到秒，如果文件在 1 秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件。而且如果文件被修改后又撤销修改了，内容还是保持原样，但是最后修改时间变了，也要重新请求。也有可能存在服务器没有准确获取文件修改时间，或与代理服务器时间不一致的情况。

为了解决文件修改时间不精确带来的问题，服务器和浏览器再次协商，这次不返回时间，返回文件的唯一标识`ETag`。只有当文件内容改变时，`ETag`才改变。`ETag`的优先级高于`Last-Modified`。

## 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

协商缓存生效 状态码返回 304
{% asset_img 1.png 协商缓存生效 %}

协商缓存失效，返回 200 和请求结果结果，如下:

{% asset_img 2.png 协商缓存失效 %}

同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified / If-Modified-Since`和 `Etag / If-None-Match`，其中 `ETag / If-None-Match` 的优先级比`Last-Modified / If-Modified-Since`高。

### `Last-Modified`/ `If-Modified-Since`

值为资源最后的更新时间，随服务器 response 返回。

`Last-Modified` 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。

`If-Modified-Since`则是客户端再次发起请求时，携带上次请求返回的 Last-Modified 值,通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有`If-Modified-Since`字段，则会根据`If-Modified-Since`字段值与该资源在服务器上的最后被修改时间做比对，若服务器最后被修改时间大于`If-Modified-Since`字段值，则返回资源，状态码为 200。否则返回 304，代表资源没有更新继续使用缓存文件。

### `ETag` / `If-None-Match`

ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)

`If-None-Match`是客户端再次发起该请求时，携带上次请求返回的唯一标识`ETag`值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有`If-None-Match`，则会根据`If-None-Match`的字段值与该资源在服务器的`ETag`值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200

## 最佳实践

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。
在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。

webpack 可以让我们在打包的时候，在文件的命名上带上 hash 值

我们可以得出一个较为合理的缓存方案：

HTML：使用协商缓存。
CSS&JS&图片：使用强缓存，文件命名带上 hash 值。

1、index.html 不做缓存，每次请求都获取最新版本
2、使用 webpack 等 build 后的其他所有资源文件（包括 js、css 和图片等），都做强缓存（一个月打底，可以设置一年）
