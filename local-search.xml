<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>react</title>
    <link href="/2023/09/11/react/"/>
    <url>/2023/09/11/react/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="React-合成事件机制"><a href="#React-合成事件机制" class="headerlink" title="React 合成事件机制"></a>React 合成事件机制</h2><ul><li>react16 事件绑定在<code>document</code>上</li><li>react17 事件绑定到 root 组件上，有利于多个 react 版本共存，例如微前端</li><li>event 不是原生的，是 SyntheticEvent 合成事件对象</li></ul><blockquote><p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的</p></blockquote><p><strong>为何需要合成事件</strong></p><ul><li>更好的兼容性和跨平台，如 react native</li><li>挂载到 document 或 root 上，减少内存消耗，避免频繁解绑</li><li>方便事件的统一管理（如事务机制）</li></ul><h2 id="setState-和-batchUpdate-机制"><a href="#setState-和-batchUpdate-机制" class="headerlink" title="setState 和 batchUpdate 机制"></a>setState 和 batchUpdate 机制</h2><p>setState 在 react 事件，生命周期中是异步的，在 setTimeout，自定义 DOM 事件中是同步的</p><h3 id="setState-主流程"><a href="#setState-主流程" class="headerlink" title="setState 主流程"></a>setState 主流程</h3><p>setState 是否是异步还是同步，看是否能命中 batchUpdate 机制，判断 isBatchingUpdates</p><p>哪些能命中 batchUpdate 机制</p><ul><li>生命周期</li><li>react 中注册的事件和它调用的函数</li><li>总之在 react 的上下文中</li></ul><h2 id="哪些不能命中-batchUpdate-机制"><a href="#哪些不能命中-batchUpdate-机制" class="headerlink" title="哪些不能命中 batchUpdate 机制"></a>哪些不能命中 batchUpdate 机制</h2><ul><li>setTimeout、setInterval 等</li><li>自定义 DOM 事件</li><li>总之不在 react 的上下文中，react 管不到</li></ul><p>在 React18 之前，setState 在 react 的合成事件中是合并更新的，在 setTimeout 的原生事件中是同步按序更新的</p><p>在 react18 之中，不论是在合成事件中，还是在宏任务重，都是合并更新</p><h2 id="调用-setState-之后会发生什么"><a href="#调用-setState-之后会发生什么" class="headerlink" title="调用 setState 之后会发生什么"></a>调用 setState 之后会发生什么</h2><p>在调用 setState 函数之后，react 会将传入的参数和之前的状态进行合并，然后触发调和过程（reconciliation）。经过调和过程，react 会以相对高效的方式根据新的状态构建 react 元素树并着手重新渲染整个 UI 界面，在 react 得到元素树之后，react 会计算出新的树和老的树之前的差异，然后根据差异对界面进行最小化重新渲染。通过 diff 算法，react 能够精确知道哪些位置发生了变化以及该如何变化，这就保证了按需更新，而不是全部渲染</p><ul><li>在 setState 的时候，react 会为当前节点创建一个 updateQueue 的更新队列</li><li>然后会触发 reconciliation 过程，在这个过程中，会使用名为 Fiber 的调度算法，开始生成新的 Fiber 树，Fiber 算法最大的特点是可以做到异步可中断的执行</li><li>然后 React scheduler 会根据优先级高低，先执行优先级高的节点，具体是执行 doWork 方法</li><li>在 doWork 方法中，react 会执行一遍 updateQueue 中的方法，已获得新的节点。然后对比新旧节点，为老街店打上更新、插入、替换等 tag。</li><li>当前节点 doWork 完成后，会执行 performUnitOfWork 方法以获得新节点，然后再重复上面的过程</li><li>当所有的节点都 doWork 完成后，会触发 commitRoot 方法，react 进入 commit 阶段</li><li>在 commit 阶段，react 会根据前面为各个节点打的 tag，一次性更新整个 dom 元素</li></ul><h2 id="react-中-key-的作用是"><a href="#react-中-key-的作用是" class="headerlink" title="react 中 key 的作用是"></a>react 中 key 的作用是</h2><ul><li>key 是 react 用于追踪哪些列表中元素被修改，被添加或者被移除的辅助标识</li><li>给每个 vnode 的唯一 id，可以依靠 key，更准确，更快的拿到 oldVnode 中对应的 vnode 节点</li><li>如果没有 key，react 会认为交换顺序的节点变化了，则会销毁这两个节点并重新构造</li><li>当我们用 key 指明了节点前后对应关系后，react 知道节点还在，就会复用该节点，只需要交换顺序</li><li>在 react diff 算法中，可以减少不必要的元素重新渲染</li></ul><h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>react fiber 用类似 requestIdleCallback 的机制来做异步 diff。但是之前数据结构不支持这样的实现异步 diff。于是 react 实现了类似链表的数据结构，将原来的递归 diff（不可被中断）变成了现在的遍历 diff，这样就能做到异步更新并且可中断恢复执行</p><p>React 的核心流程可以分为两个部分：</p><ul><li><p>reconciliation（调度算法），render</p><ol><li>更新 state 与 props</li><li>调用生命周期钩子</li><li>生成虚拟 dom（这里是 fiber tree）</li><li>通过新旧 vdom 进行 diff 算法，获取 vdom change</li><li>确认是否需要重新渲染</li></ol></li><li><p>commit<br>如需要，则操作 dom 节点更新</p></li></ul><p>新版的 fiber reconciler，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启</p><p>这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>Fiber 是一种数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">instance</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = instance;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = child;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = parent;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = previous;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>链表树遍历算法：通过节点保存与映射，便能随时地进行停止和重启，这样便能达到实现任务分割的基础前提。</p></li><li><p>任务分割：reconciliation 和 commit 两个阶段</p></li><li><p>分散执行： 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新 API: requestIdleCallback 与 requestAnimationFrame</p></li></ul><p>低优先级的任务交给 requestIdleCallback 处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 polyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；</p><p>高优先级任务交给 requestAnimationFrame 处理</p><ul><li>优先级策略：文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>responsive layout</title>
    <link href="/2023/09/07/responsive-layout/"/>
    <url>/2023/09/07/responsive-layout/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器事件循环机制</title>
    <link href="/2023/09/06/event-loop/"/>
    <url>/2023/09/06/event-loop/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ol><li>进程中的任一线程执行出错，都会导致整个进程的崩溃</li><li>线程之间共享进程中的数据</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存</li><li>进程之间的内容相互隔离</li></ol><h2 id="多进程架构浏览器"><a href="#多进程架构浏览器" class="headerlink" title="多进程架构浏览器"></a>多进程架构浏览器</h2><ul><li>浏览器进程：主要负责界面显示，用户交互，子进程管理，同时提供存储等功能</li><li>渲染进程：核心任务是将 HTML，CSS 和 js 转换为用户可以与之交互的网页，排版引擎 Blink 和 js 引擎 V8 都是运行在此进程中。chrome 会为每个 tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU 进程：网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。</li><li>网络进程：主要负责页面的网络资源加载。</li><li>插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><blockquote><p>缺点</p><ul><li>更高的资源占用。因为每个进程都会包含公共进出结构的副本</li><li>更复杂的体系结构</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器</title>
    <link href="/2023/09/06/browser-render/"/>
    <url>/2023/09/06/browser-render/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ol><li>进程中的任一线程执行出错，都会导致整个进程的崩溃</li><li>线程之间共享进程中的数据</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存</li><li>进程之间的内容相互隔离</li></ol><h2 id="多进程架构浏览器"><a href="#多进程架构浏览器" class="headerlink" title="多进程架构浏览器"></a>多进程架构浏览器</h2><img src="/2023/09/06/browser-render/multi-frame.webp" class="" title="multi-frame"><ul><li>浏览器进程：主要负责界面显示，用户交互，子进程管理，同时提供存储等功能</li><li>渲染进程：核心任务是将 HTML，CSS 和 js 转换为用户可以与之交互的网页，排版引擎 Blink 和 js 引擎 V8 都是运行在此进程中。chrome 会为每个 tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU 进程：网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。</li><li>网络进程：主要负责页面的网络资源加载。</li><li>插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><blockquote><p>缺点</p><ul><li>更高的资源占用。因为每个进程都会包含公共进出结构的副本</li><li>更复杂的体系结构</li></ul></blockquote><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><p>从输入 URL 到页面展示完整流程示意图</p><img src="/2023/09/06/browser-render/browser-render.webp" class="" title="browser-render"><p>大致过程如下：</p><ul><li>首先用户从浏览器进程里输入请求信息</li><li>然后网络进程发起 URL 请求</li><li>服务器响应请求后，浏览器进程就又要开始准备渲染进程了</li><li>渲染进程准备好之后，需要现象需要先向渲染进程提交页面数据，我们称之为提交文档阶段</li><li>渲染进程接收完文档信息后，便开始解析页面和加载子资源，完成页面渲染</li></ul><h3 id="从输入-URL-到页面展示"><a href="#从输入-URL-到页面展示" class="headerlink" title="从输入 URL 到页面展示"></a>从输入 URL 到页面展示</h3><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>当用户在地址栏输入一个关键字时，地址栏会判断输入的关键字是搜索内容还是请求的 URL</p><ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL</li><li>如果判断输入内容符合 URL 规则，那么地址栏会根据规则，将内容加上协议，合成完整的 URL</li></ul><p>此时浏览器标签栏会进入加载状态，页面内容需要等待提交文档阶段时才会被替换</p><h3 id="URL-请求过程"><a href="#URL-请求过程" class="headerlink" title="URL 请求过程"></a>URL 请求过程</h3><p>接下来，便进入了页面资源请求过程。这时浏览器进程会通过进程间通信 IPC 把 URL 请求发送至网络进程，网络进程收到请求后，会在这里发起真正 的 URL 请求流程</p><p>具体流程如下：</p><ul><li>首先<strong>网络进程</strong>会查找本地缓存是否缓存了资源。如果有缓存资源，那么直接返回资源给浏览器进程</li><li>如果在缓存中没有找到资源，那么直接进入网络请求流程，这请求第一步是进行 DNS 解析，以获取请求域名和 ip 如果协议是 https，还会建立 TLS 连接。</li><li>接下来就是利用 IP 和服务器建立 TCP 连接。连接建立之后，浏览器会构建请求行，请求头等信息，并把和该域名相关的 cookie 等数据附加请求头中，然后向服务器发送构建的请求信息。</li><li>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行，响应头和响应体等信息），并发给网络进程。等网络进程接收到了响应行和响应头之后，就解析响应头的内容。</li></ul><p>（1）<strong>重定向</strong><br>在收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或 302，那么说明服务器需要浏览器重定向到其他 URL，这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始。</p><p>（2） <strong>相应数据类型处理</strong><br>在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候会是下载类型，有时是正常的 HTML 页面，那么浏览器如何区分：</p><h4 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h4><p>它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p><p>如果 content-type 值为 application&#x2F;octet-stream,显示的是字节流类型，浏览器会将请求提交给下载管理器，同时 URL 请求的导航流程就到此结束。</p><p>如果是 html 类型，接下来准备渲染进程了。</p><h3 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h3><p>默认情况下，chrome 会为每个页面分配一个渲染进程，但也有例外，多个页面直接运行在一个渲染进程下面。只有属于同一个站点下的域名会使用同个渲染进程。</p><p>我们将“同一站点”定义为根域名（例如，baidu.com）加上协议（例如，https:&#x2F;&#x2F; 或者 http:&#x2F;&#x2F;），还包含了该根域名下的所有子域名和不同的端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下都属于同一个站点</span><br>https://www.baidu.com<br>https://map.baidu.com<br>https://www.baidu.com:8080<br></code></pre></td></tr></table></figure><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p><p>打开一个新页面采用的渲染进程策略就是：</p><p>通常情况下，打开新的页面都会使用单独的渲染进程；</p><ul><li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；</li><li>如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><h3 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h3><p>这里的“文档”是指 URL 请求的响应体数据。</p><blockquote><p>提交文档的消息由浏览器进程发出，渲染进程收到提交文档消息后，会和网络进程建立传输数据的管道。<br>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。<br>浏览器进程在收到“确认提交”消息后，会更新浏览器界面状态，包含了安全状态，地址栏 URL，前进后退的历史状态，并更新 web 页面。</p></blockquote><p>到这里导航的流程走完了，之后进入渲染阶段。</p><h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载，渲染的流水线分为几个阶段：构建 DOM 树，样式计算，布局阶段，分层，绘制，分块，光栅化和合成。</p><h4 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h4><p>输入：HTML<br>输出：DOM 树</p><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p><ol><li>把 css 转为浏览器能理解的结构</li></ol><p>渲染引擎在收到 css 文本后，会执行一个转换操作，将 css 文本转换为浏览器可以理解的结构–styleSheets，该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p><ol start="2"><li>转换样式表中的属性值，使其标准化</li></ol><p>将 css 属性值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p><ol start="3"><li>计算出 DOM 树中每个节点的具体样式</li></ol><p>样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 <strong>CSS 的继承</strong>和<strong>层叠</strong>两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 <code>ComputedStyle</code> 的结构内</p><h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p><p>chrome 在布局阶段需要完成两个任务：创建布局树和布局计算.</p><ol><li>布局树的构造过程：</li></ol><img src="/2023/09/06/browser-render/layout-dom.webp" class="" title="layout-dom"><p>为了构建布局树，浏览器大体上完成了下面这些工作</p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容。</li></ul><ol start="2"><li>布局计算</li></ol><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了</p><p>在执行布局操作的时候，会把布局计算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容。</p><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>因为页面中有很多复杂效果，如一些复杂的 3D 变换，页面滚动，或者使用 z-index 做 z 轴排序，为了更加方便的实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。正是这些图层叠加在一起构成了最终的页面图像。</p><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><p>满足下面两点中任意一点的元素就可以被提升为单独的一个图层</p><ol><li>拥有层叠上下文属性的元素会被提升位单独的一层<br>页面是一个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</li></ol><p><strong>明确定位属性的元素，定义透明属性的元素，使用 CSS 滤镜的元素，都有层叠上下文属性。</strong></p><ol start="2"><li>需要剪裁的地方也会被创建为图层</li></ol><p>div 里面的文字内容多，超出 div 所显示的区域，就会发生剪裁，出现这种裁减情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</p><h4 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h4><p>渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。</p><h4 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h4><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由<strong>渲染引擎</strong>中的<strong>合成线程</strong>来完成。</p><img src="/2023/09/06/browser-render/raster.webp" class="" title="raster"><p>如上图所示：当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程。</p><p><strong>合成线程的工作原理</strong></p><p>合成线程会将图层划分为图块，这些图块大小通常是 256x256 或者 512x512</p><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图，而<strong>图块是栅格化执行的最小单位</strong>。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。运行方式如下：</p><img src="/2023/09/06/browser-render/raster-operation.webp" class="" title="raster-operation"><p>通常栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><img src="/2023/09/06/browser-render/raster-gpu.webp" class="" title="gpu"><p>渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><h4 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h4><p>一旦所有的图块都被光栅化，合成线程就会生成一个绘制图块的命令（DrawQuad），然后将该命令交给浏览器进程。</p><p>浏览器进程里有一个 viz 组件，用来接受合成线程发来的 DrawQuad 命令，然后根据该命令，将其页面内容绘制在内存中，最后再将内存显示在屏幕上。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个渲染流程如下：</p><img src="/2023/09/06/browser-render/render.webp" class="" title="渲染流程"><img src="/2023/09/06/browser-render/relayout.webp" class="" title="relayout"><p>结合上图，一个完整的渲染流程大致可总结为如下</p><ul><li>渲染进程将 HTML 内容转换为浏览器能够读懂的 DOM 树结构</li><li>渲染引擎将 css 样式表转化为浏览器可以理解的 stylesheets，计算出 DOM 节点的样式</li><li>创建布局树，并计算元素的布局信息</li><li>对布局树进行分层，并生成分层树</li><li>为每个图层生成绘制列表，并将其提交到合成线程</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换为位图</li><li>合成线程发送绘制图块命令到浏览器进程</li><li>浏览器进程根据命令信息生成页面，并显示到显示器上</li></ul><h3 id="重排-更新了元素的几何属性"><a href="#重排-更新了元素的几何属性" class="headerlink" title="重排 (更新了元素的几何属性)"></a>重排 (更新了元素的几何属性)</h3><img src="/2023/09/06/browser-render/relayout.webp" class="" title="重排"><p>通过 css、js 修改元素的几何位置属性，例如改变元素的宽度，高度，浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排是要更新完整的渲染流水线，所以开销也大。</p><h3 id="重绘-更新了元素的绘制属性"><a href="#重绘-更新了元素的绘制属性" class="headerlink" title="重绘 (更新了元素的绘制属性)"></a>重绘 (更新了元素的绘制属性)</h3><img src="/2023/09/06/browser-render/repaint.webp" class="" title="重绘"><p>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘.</p><p>相较于重排，重绘省去了布局和分层阶段，所以执行效率会比重排操作更高一些</p><h3 id="直接合成阶段"><a href="#直接合成阶段" class="headerlink" title="直接合成阶段"></a>直接合成阶段</h3><p>渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。</p><img src="/2023/09/06/browser-render/compute.webp" class="" title="compute"><p>在使用了 css 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在主线程上执行合成动画操作，因为是在非主线程上来合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段。</p><h3 id="实践中优化减少重排重绘的方法"><a href="#实践中优化减少重排重绘的方法" class="headerlink" title="实践中优化减少重排重绘的方法"></a>实践中优化减少重排重绘的方法</h3><ul><li>触发 repaint，reflow 的操作尽量放在一起，避免出现多次重排</li><li>通过虚拟 dom 层计算出操作总的差异，一起提交给浏览器。之前还用<code>createdocumentfragment</code>来汇总 append 的 dom,来减少触发重排重绘次数。</li></ul><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独区域中，合格区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，他们是独立存在的。</p><p>在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用块内部的变量压到栈顶，当作用域执行完成后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</p><p>当执行到作用域块中的 console.log(a)时，就需要在词法环境和变量环境中查找变量 a 的值，具体查找方式是：沿着词法环境的栈顶乡下查询，如果在词法环境中的某个人块中找到了，就会直接返回给 js 引擎，如果没有找到，就会继续在变量环境中查找</p><img src="/2023/09/06/browser-render/exclusive.webp" class="" title="exclusive"><p><strong>块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的</strong>。通过这两者结合，js 引擎也就同时支持了变量提升和块级作用域了。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><blockquote><p>词法作用域是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它能够预测代码在执行过程中如何查找标识符。</p></blockquote><p>js 的作用域链由词法作用域决定的，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</p><p>块级作用域中，当要查找一个在当前作用域中不存在的变量，就会按照作用域链在其他作用域中查找该变量。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>定义：在 js 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包.</p><p>闭包中 js 引擎会沿着<strong>当前执行上下文-&gt;闭包函数-&gt;全局执行上下文</strong>顺序来查找变量</p><h3 id="闭包是如何回收的"><a href="#闭包是如何回收的" class="headerlink" title="闭包是如何回收的"></a>闭包是如何回收的</h3><p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p><p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p><p>所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="调用栈中的数据"><a href="#调用栈中的数据" class="headerlink" title="调用栈中的数据"></a>调用栈中的数据</h3><p>当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP（一个记录当前执行状态的指针） 来销毁该函数保存在栈中的执行上下文。</p><h3 id="堆中数据"><a href="#堆中数据" class="headerlink" title="堆中数据"></a>堆中数据</h3><h4 id="代际假说（The-Generational-Hypothesis）和分代收集"><a href="#代际假说（The-Generational-Hypothesis）和分代收集" class="headerlink" title="代际假说（The Generational Hypothesis）和分代收集"></a>代际假说（The Generational Hypothesis）和分代收集</h4><p>代际假说两大特点：</p><ul><li>大部分对象在内存中存在的时间很短，很多对象已经分配内存，很快就变得不可访问</li><li>不死的对象，会活得很久</li></ul><p>在 V8 中会把<strong>堆分为<em>新生代</em>和<em>老生代</em>两个区域</strong>，<strong>新生代中存放的就是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p><p>新生区只支持 1~8M 的容量，而老生区支持的容量就很大。V8 分别使用两个不同的垃圾回收器，</p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收</li><li>主垃圾回收器，主要负责老生代的垃圾回收</li></ul><h4 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h4><ol><li>标记空间中的活动对象和非活动对象。活动对象是还在使用的对象，非活动对象是可以进行垃圾回收的对象</li><li>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象</li><li>做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</li></ol><h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>副垃圾回收器主要负责新生区的垃圾回收。通常情况下，大多数小的对象都会被分配在新生区，垃圾回收比较频繁。</p><p>新生代中用 Scavenge 算法来处理。Scavenge 算法：是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p><img src="/2023/09/06/browser-render/scavenge.png" class="" title="scavenge"><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时还会把这些对象有序的排列起来，所以这个复制过程也完成了内存整理操作，复制后空闲区域内就没有内存碎片了</p><p>完成复制后，对象区域与空闲区域就进行角色翻转，也就是原来的对象区域变为空闲区域，原来的空闲区域变成对象区域，这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，所以新生区的空间一般设置的比较小</p><p>因为新生区空间不大，很容易被存活的对象装满了整个区域，为了解决这个问题，js 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然存货的对象，会被移动到老生区</p><h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>主垃圾回收器主要负责老生区中的垃圾回收</p><p>除了新生区晋升的对象，一些大的对象会直接被分配到老生区。因此老生区的对象有两个特点，一个是占用空间大，一个是对象存活时间长</p><p>主垃圾回收器是采用 <strong>标记-清除（mark-sweep）算法</strong>进行垃圾回收</p><p>首先是标记过程阶段，标记阶段是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p><p>接下来是垃圾的清楚过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程。</p><p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><img src="/2023/09/06/browser-render/mark-compact.png" class="" title="mark-compact"><h3 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h3><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p><img src="/2023/09/06/browser-render/incremental-mark.png" class="" title="incremental-mark"><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了</p><h2 id="XMLHttpRequest-运行机制"><a href="#XMLHttpRequest-运行机制" class="headerlink" title="XMLHttpRequest 运行机制"></a>XMLHttpRequest 运行机制</h2><img src="/2023/09/06/browser-render/xmlhttprequest.png" class="" title="xmlhttprequest"><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p><p>主要两种形式：</p><ul><li>把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</li><li>执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现</li></ul><p>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p><h4 id="产生微任务的方式"><a href="#产生微任务的方式" class="headerlink" title="产生微任务的方式"></a>产生微任务的方式</h4><ol><li><p>使用 <code>MutationObserver</code> 监控某个 DOM 节点，然后再通过 js 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p></li><li><p>使用 <code>Promise</code>，当调用 Promise.resolve()或者 Promise.reject()的时候，也会产生微任务</p></li></ol><h4 id="微任务队列的执行时机"><a href="#微任务队列的执行时机" class="headerlink" title="微任务队列的执行时机"></a>微任务队列的执行时机</h4><p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p><p>如果在执行微任务的过程，产生了新的微任务，同样会将该微任务添加到微任务列表中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前宏任务中继续执行。</p><img src="/2023/09/06/browser-render/mircotask.png" class="" title="mirco"><p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p><p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文</p><h3 id="MutationObserver-执行机制"><a href="#MutationObserver-执行机制" class="headerlink" title="MutationObserver 执行机制"></a>MutationObserver 执行机制</h3><p>Mutation 将相应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。</p><p>在每次 DOM 节点发生变化时，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了</p><p>综上所述， MutationObserver 采用了“异步 + 微任务”的策略。</p><ul><li>通过异步操作解决了同步操作的性能问题</li><li>通过微任务解决了实时性问题</li></ul><h2 id="async-await-底层实现机制"><a href="#async-await-底层实现机制" class="headerlink" title="async&#x2F;await 底层实现机制"></a>async&#x2F;await 底层实现机制</h2><h3 id="生成器-协程"><a href="#生成器-协程" class="headerlink" title="生成器 &amp;&amp; 协程"></a>生成器 &amp;&amp; 协程</h3><p>生成器函数是一个带星号的函数，可以暂停执行和回复执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">genDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; 开始执行第一段 &quot;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;generator 2&quot;</span>;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; 开始执行第二段 &quot;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;generator 2&quot;</span>;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; 开始执行第三段 &quot;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;generator 2&quot;</span>;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; 执行结束 &quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;generator 2&quot;</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;main 0&quot;</span>);<br><span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">genDemo</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;main 1&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;main 2&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;main 3&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;main 4&quot;</span>);<br></code></pre></td></tr></table></figure><p>生成器函数具体使用方式：</p><ul><li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 js 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li><li>外部函数可以通过 next 方法恢复函数的执行</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程是一种比线程更轻量级的存在，可以把协程看成跑在线程上的任务，一个线程上可以有多个协程，但是在线程上同时只能执行一个协程。通常如果从 a 协程启动 b 协程，我们把 a 协程称为 b 协程的父协程。</p><p>协程不是被操作系统内核所管理的，而完全由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了提升，不会产生切换。</p><p>协程执行过程图：</p><img src="/2023/09/06/browser-render/coroutine.png" class="" title="coroutine"><p>协程的四点规则：</p><ul><li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后 gen 协程并没有立即执行</li><li>要让 gen 协程执行，需要调用 gen.next</li><li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程</li><li>如果协程在执行期间遇到了 return 关键字，那么 js 引擎就会结束当前协程，并将 return 后面的内容返回给父协程</li></ul><p>gen 协程和父协程是在主协程上交互执行的，并不是并发执行的，他们之间的切换是通过 yield 和 gen.next 来配合完成</p><p>当在 gen 协程中调用了 yield 方法时，js 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，js 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息</p><p>父协程和 gen 协程的切换调用栈</p><img src="/2023/09/06/browser-render/switch-stack.png" class="" title="switch-stack"><p>在 js 中，生成器是协程的一种实现方式。</p><h3 id="async-await-原理"><a href="#async-await-原理" class="headerlink" title="async&#x2F;await 原理"></a>async&#x2F;await 原理</h3><p>async&#x2F;await 技术背后的就是 Promise 和生成器应用，往底层了说就是微任务和协程</p><p><strong>async</strong></p><p>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数</p><p><strong>await</strong></p><p>async&#x2F;await 执行流程图</p><img src="/2023/09/06/browser-render/async-await.png" class="" title="async-await"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">100</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 0 1 3 100 2</span><br></code></pre></td></tr></table></figure><p>首先执行 console.log(0);，打印 0<br>接着执行 foo 函数，由于 foo 被 async 标记过，所以当进入该函数的时候，js 会保存当前的调用栈信息，然后执行 console.log(1);<br>接下来执行到 await 100 的时候，会默认创建一个 Promise 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise_ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>((resolve, reject) &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在这个 promise<em>对象创建过程中，js 引擎会将该任务提交给微任务队列<br>然后 js 引擎会暂停当前的协程执行，将主线程的控制权交给父协程执行，同时会将 promise</em>对象返回给父协程</p><p>主线程的控制权已经交给了父协程，父协程需要调用 promise_.then 来监控 promise 状态的改变</p><p>接下来继续执行父协程的流程，这里执行 console.log(3)。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，里面存在 resolve(100)待执行，执行到这里的时候，会触发 promise_.then 中的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">promise_.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 回调函数被激活后，将主线程控制权交给foo协程，并将value传给协程</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p><h2 id="页面性能分析"><a href="#页面性能分析" class="headerlink" title="页面性能分析"></a>页面性能分析</h2><h3 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h3><ol><li>排队时间过久</li></ol><p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，这种方案称为域名分片技术。还可以将站点升级到 http2，因为 http2 已经没有每个域名最多维护 6 个 tcp 连接的限制了。</p><ol start="2"><li>第一字节时间（TTFB）时间过久</li></ol><ul><li>服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li><li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li><li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li></ul><ol start="3"><li>Content Download 时间过久</li></ol><p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致。这时候就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p><h3 id="Dom-树构建"><a href="#Dom-树构建" class="headerlink" title="Dom 树构建"></a>Dom 树构建</h3><p>JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p><p>Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，</p><p>async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 <code>DOMContentLoaded</code> 事件之前执行。</p><h3 id="CSSDom-树构建"><a href="#CSSDom-树构建" class="headerlink" title="CSSDom 树构建"></a>CSSDom 树构建</h3><img src="/2023/09/06/browser-render/css-render.png" class="" title="css-render"><p>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。</p><h4 id="白屏优化"><a href="#白屏优化" class="headerlink" title="白屏优化"></a>白屏优化</h4><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li><li>尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的的注释，压缩 js 文件</li><li>将一些不需要再解析 HTML 阶段使用的 js 标记上 async 或者 defer</li><li>对于大的 css 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 css 文件，这样只有在特定的场景下才会加载特定的 css 文件</li></ul><h3 id="利用分层技术优化"><a href="#利用分层技术优化" class="headerlink" title="利用分层技术优化"></a>利用分层技术优化</h3><p>添加 will-change 的 css 属性，提前告诉渲染引擎将要做一些变化，渲染引擎会将该元素单独实现一帧，等变化发生时，渲染引擎会通过合成线程直接去处理变化，这些变换并没有涉及到主线程，这样就大大提升了渲染效率。</p><p>如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p><h3 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h3><ol><li>减少 js 脚本执行时间</li></ol><ul><li>将一次执行的函数分解为多个任务，使得每次执行时间不要过久</li><li>采用 web workers</li></ul><ol start="2"><li>避免强制同步布局</li></ol><p>强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中</p><ol start="3"><li>避免布局抖动</li></ol><p>布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p><p>尽量不要在修改 DOM 结构时再去查询一些相关值。</p><ol start="4"><li>合理利用 css 合成动画</li></ol><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p><p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p><ol start="5"><li>避免频繁地垃圾回收</li></ol><p>我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p><p>所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p><h2 id="webComponent"><a href="#webComponent" class="headerlink" title="webComponent"></a>webComponent</h2><p>要使用 webComponent，需要实现下面三个步骤</p><ol><li>首先使用 template 属性来创建模板。</li><li>其次 我们需要创建一个类，在该类的构造函数中要完成 3 件事：</li></ol><ul><li>查找模板内容</li><li>创建影子 Dom</li><li>再将模板添加到影子 DOM 上</li></ul><p>影子 DOM 的作用是将模板中的内容与全局 DOM 和 css 进行隔离，这样我们就可以实现元素和样式的私有化。在创建好封影子 DOM 的类之后，我们就可以使用 customElements.define 来自定义元素了。影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。</p><ol start="3"><li>最后像使用 HTML 元素一样使用该元素</li></ol><h2 id="浏览器网络"><a href="#浏览器网络" class="headerlink" title="浏览器网络"></a>浏览器网络</h2><h3 id="http1-1-优化"><a href="#http1-1-优化" class="headerlink" title="http1.1 优化"></a>http1.1 优化</h3><ul><li>增加了持久连接</li><li>浏览器为每个域名最多同时维护 6 个 TCP 连接</li><li>使用 CDN 的实现名片机制</li></ul><h3 id="http1-1-主要问题"><a href="#http1-1-主要问题" class="headerlink" title="http1.1 主要问题"></a>http1.1 主要问题</h3><p>http1.1 对带宽的利用率并不理想。带宽是指每秒最大能发送或者接收的字节数。每秒能发送的最大字节数称为上行带宽，没笑能够接收的最大字节数成为下行带宽。</p><p>之所以说 HTTP&#x2F;1.1 对带宽的利用率不理想，是因为 HTTP&#x2F;1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M&#x2F;S，而采用 HTTP&#x2F;1.1 时，也许在加载页面资源时最大只能使用到 2.5M&#x2F;S，很难将 12.5M 全部用满。</p><p>原因如下：</p><ol><li><p>TCP 的慢启动<br>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p><p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p><p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p></li><li><p>同时开启了多条 TCP 连接，那么这么多连接会竞争固定的带宽<br>因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p></li><li><p>http1.1 队头阻塞问题<br>在 HTTP&#x2F;1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p></li></ol><h3 id="http2-的多路复用"><a href="#http2-的多路复用" class="headerlink" title="http2 的多路复用"></a>http2 的多路复用</h3><p>HTTP&#x2F;2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p><p>HTTP&#x2F;2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p><p>http2 添加了一个二进制分帧层，如下 HTTP2 请求和接收过程</p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。<br>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。<br>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求</li></ul><h3 id="http2-其他特性"><a href="#http2-其他特性" class="headerlink" title="http2 其他特性"></a>http2 其他特性</h3><ol><li><p>可以设置请求的优先级<br>HTTP&#x2F;2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p></li><li><p>服务器推送<br>除了设置请求的优先级外，HTTP&#x2F;2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p></li><li><p>头部压缩<br>HTTP&#x2F;2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p></li></ol><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</p><p>同源策略主要表现在 DOM，web 数据和网络三个层面</p><ul><li>DOM 层面。同源策略限制了来自不同源的 js 脚本对当前 DOM 对象读和写的操作</li><li>数据层面。同源策略限制了不同源站点读取当前站点的 Cookie，indexDB，localStorage 等数据。</li><li>网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序</title>
    <link href="/2023/09/06/mini-program/"/>
    <url>/2023/09/06/mini-program/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="unionid-openid"><a href="#unionid-openid" class="headerlink" title="unionid &amp; openid"></a>unionid &amp; openid</h3><h4 id="unionid"><a href="#unionid" class="headerlink" title="unionid"></a>unionid</h4><p>unionid 是一个用户对应同主体微信小程序&#x2F;公众号&#x2F;app 的标识，开发者需要再微信开放平台下绑定相同账号的主体。开发者可以通过 UnionId,实现多个小程序、公众号甚至 app 之间数据互通</p><h4 id="openid"><a href="#openid" class="headerlink" title="openid"></a>openid</h4><p>openid 是一个用户对于一个小程序&#x2F;公众号的标识，开发者可以通过这个标识识别出用户</p><h3 id="登录流程设计"><a href="#登录流程设计" class="headerlink" title="登录流程设计"></a>登录流程设计</h3><ol><li><p>利用现有的登录体系<br>直接复用现有系统的登录体系， 只需要在小程序端设计用户名，密码&#x2F;验证码输<br>⼊页面，便可以简便的实现登录， 只需要保持良好的用户体验即可</p></li><li><p>利用 OpenId 创建用户体系<br>OpenId 是⼀个⼩程序对于⼀个用户的标识，利用这⼀点我们可以轻松的实<br>现⼀套基于⼩程序的用户体系，值得⼀提的是这种用户体系对用户的打扰最<br>低， 可以实现静默登录 。具体步骤如下：</p><ul><li>小程序客户端通过 <code>wx.login</code> 获取 <code>code</code></li><li>传递 <code>code</code> 向服务端，服务端拿到 <code>code</code> 调用微信登录凭证校验接口，微信服务器返回 <code>openId</code> 和会话密钥 <code>session_key</code>，此时开发者服务端可以利用 <code>openid</code> 生成用户入库，再向小程序客户端返回自定义登录态</li><li>小程序客户端缓存自定义登录态（token），后续调用 api 携带此 token</li></ul></li><li><p>利用 unionId 创建用户体系</p></li></ol><ul><li><p>如果户关注了某个相同主体公众号， 或曾经在某个相同主体 App 、公众号上进行过微信登<br>录授权， 通过 wx.login 可以直接获取 到 unionid</p></li><li><p>结合 wx.getUserInfo 和 <code>&lt;button open-type=&quot;getUserInfo&quot;&gt;&lt;button/&gt;</code> 这两种⽅式引导用户主动授权， 主动授权后通过返回的信息和服务端交互 (这里有⼀步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录。<br>具体示例：</p><blockquote><ol><li>调用 <code>wx.login</code> 获取 <code>code</code> ，然后从微信后端换取到 <code>session_key</code> ，用于 解密<code>getUserInfo</code> 返回的敏感数据</li><li>使用 <code>wx.getSetting</code> 获取用户的授权情况</li><li>如果用户已经授权， 直接调用 API <code>wx.getUserInfo</code> 获取用户最新的信息；</li><li>用户未授权，在界面中显示⼀个按钮提示用户登⼊， 当用户点击并授权后就获取到用<br>户的最新信息</li><li>获取到用户数据后可以进行展示或者发送给自⼰的后端。</li></ol></blockquote></li></ul><h2 id="双线程模型"><a href="#双线程模型" class="headerlink" title="双线程模型"></a>双线程模型</h2><img src="/2023/09/06/mini-program/double-thread-frame.png" class="" title="double-thread-frame"><p>小程序的渲染层和逻辑层分别由两个线程管理：渲染层的界面使用 webView 进行渲染；逻辑层采用 jsCore 运行 js 代码。一个小程序存在多个界面，所以渲染层存在多个 webView。这两个线程间的通信有小程序 Native 侧中转，逻辑层发送网络请求也经由 Native 侧转发，小程序的通信模型为：</p><img src="/2023/09/06/mini-program/wechat-miniprogram-framework.png" class="" title="wechat-miniprogram"><p>微信小程序视图层是 WebView，逻辑层是 JS 引擎。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>Android</td><td>V8</td><td>Chromium 定制内核</td></tr><tr><td>iOS</td><td>jsCore</td><td>WKWebView</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><p>我们看一下单 WebView 实例与小程序双线程多实例代码执行的差异点</p><img src="/2023/09/06/mini-program/double-thread.png" class="" title="double-thread"><p>多 WebView 模式下，每一个 WebView 都有一个独立的 JSContext，虽然可以通过窗口通信实现数据传递，但是无法共享数据和方法，对于全局的状态管理也相对比较复杂，抽离一个通用的 WebView 或者 JS Engine 作为应用的 JSContext 就可以解决这些问题，但是同时引入了其他问题：视图和逻辑如何通信，在小程序里面数据更新后视图是异步更新的。</p><p>双线程交互的生命周期图示：</p><img src="/2023/09/06/mini-program/lifecycle.png" class="" title="lifecycle"><h2 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h2><p>小程序逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。</p><blockquote><p>iOS 通过 <strong><code>window.webkit.messageHandlers.invokeHandler.postMessage</code></strong> 来与 Native 通信<br>Android 通过 X5 内核的 <strong><code>window.WeixinJSCore.invokeHandler</code></strong> 来与 Native 通信</p></blockquote><h3 id="视图层组件"><a href="#视图层组件" class="headerlink" title="视图层组件"></a>视图层组件</h3><p>内置组件中有部分组件是利用到客户端原生提供的能量，既然需要客户端原生提供的能力，那就会涉及到视图层和客户端的交互通信。这层通信机制在 iOS 和安卓系统的实现方式并不一样。iOS 是利用了 WKWebView 提供的 messageHandlers 特性，安卓是往 WebView 的 window 对象上注入了一个原生方法，最终会被封装为 WeXinJSBridge 这样一个兼容层，主要提供调用（invoke）和监听（on）方法。</p><p>我们知道微信小程序逻辑层没有浏览器的 DOM&#x2F;BOM，视图层的更新借助于 Virtual DOM。用 JS 对象模拟 DOM 树 -&gt; 比较两棵虚拟 DOM 树的差异 -&gt; 把差异应用到真正的 DOM 树上，状态更新的时候，通过对比前后 JS 对象变化，进而改变视图层的 Dom 树。实际上，在视图层与客户端的交互通信中，开发者只是间接调用的，真正调用是在组件的内部实现中。开发者插入一个原生组件，一般而言，组件运行的时候被插入到 DOM 树中，会调用客户端接口，通知客户端在哪个位置渲染一块原生界面。在后续开发者更新组件属性时，同样地，也会调用客户端提供的更新接口来更新原生界面的某些部分。</p><h3 id="逻辑层接口"><a href="#逻辑层接口" class="headerlink" title="逻辑层接口"></a>逻辑层接口</h3><p>逻辑层与客户端原生通信机制与渲染层类似，不同在于，iOS 平台可以往 JavaScripCore 框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。</p><p>同样地，开发者也是间接地调用到与客户端原生通信的底层接口。一般我们会对逻辑层接口做层封装后才暴露给开发者，封装的细节可能是统一入参、做些参数校验、兼容各平台或版本问题等等。</p><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>wxml 可以先转成 js 对象，然后再渲染出真正的 Dom 树，示例如下：</p><img src="/2023/09/06/mini-program/example.png" class="" title="example"><p>通过 setData 把 msg 数据从“Hello World”变成“Goodbye”，产生的 JS 对象对应的节点就会发生变化，此时可以对比前后两个 JS 对象得到变化的部分，然后把这个差异应用到原来的 Dom 树上，从而达到更新 UI 的目的，这就是“数据驱动”。</p><h2 id="快速渲染设计原理"><a href="#快速渲染设计原理" class="headerlink" title="快速渲染设计原理"></a>快速渲染设计原理</h2><p>小程序采用多个 webview 渲染，更加接近原生 App 的用户体验。</p><p>如果为单页面应用，单独打开一个页面，需要先卸载当前页面结构，并重新渲染。</p><p>多页面应用，新页面直接滑动出来并且覆盖在旧页面上即可。这样用户体验非常好。</p><h3 id="小程序启动流程"><a href="#小程序启动流程" class="headerlink" title="小程序启动流程"></a>小程序启动流程</h3><img src="/2023/09/06/mini-program/start.png" class="" title="start"><h2 id="WXML-设计思路"><a href="#WXML-设计思路" class="headerlink" title="WXML 设计思路"></a>WXML 设计思路</h2><p>程序自行搭建了组件组织框架 Exparser 框架</p><p>Exparser 的组件模型与 WebComponents 标准中的 ShadowDOM 高度相似</p><p>在小程序中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;view class=&quot;container&quot;&gt;<br>  Weixin<br>  &lt;text style=&quot;position:relative;&quot;&gt;文本&lt;/text&gt;<br>&lt;/view&gt;<br>&lt;button bindtap=&quot;test&quot;&gt;按钮&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>会被 exparser 框架会加上述结构转换为下面样子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">wx-view</span></span><br><span class="hljs-tag">  <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">&quot;2&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>  Weixin<br>  <span class="hljs-tag">&lt;<span class="hljs-name">wx-text</span></span><br><span class="hljs-tag">    <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">&quot;3&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative;&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&lt;/wx-text<br>  &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">wx-view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wx-button</span></span><br><span class="hljs-tag">  <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">&quot;4&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">exparser:info-attr-bindtap</span>=<span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;button&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">aria-disabled</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>  按钮<br><span class="hljs-tag">&lt;/<span class="hljs-name">wx-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就和 WebComponents 基本一致</p><h3 id="WebComponents"><a href="#WebComponents" class="headerlink" title="WebComponents"></a>WebComponents</h3><p>Web Components 是一个浏览器原生支持的组件化方案，允许你创建新的自定义、可封装、可重用的 HTML 标记。不用加载任何外部模块，直接就可以在浏览器中跑。</p><p>如下代码，标签就是自定义组件的标签了，它不属于 html 语义化标签中的任何一个，是自定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">user-body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user-body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userCardId&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 组件样式与代码封装在一起，只对自定义元素生效，不会影响外部的全局样式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      name &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-tag">button</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>21312<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">super</span>();</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> shadow = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> &#125;);</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> templateElem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;userCardId&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> content = templateElem.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        shadow.<span class="hljs-title function_">appendChild</span>(content);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;user-card&quot;</span>, <span class="hljs-title class_">UserCard</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>WebComponent 主要就是三个规范：</p><h4 id="custom-Elements-规范"><a href="#custom-Elements-规范" class="headerlink" title="custom Elements 规范"></a>custom Elements 规范</h4><p>可以创建一个自定义标签。根据规范，自定义元素的名称必须包含连接线”-“,用于区别原生 html 元素</p><p>可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用</p><h4 id="templates-规范"><a href="#templates-规范" class="headerlink" title="templates 规范"></a>templates 规范</h4><p>提供了<code>&lt;template&gt;</code> 标签，可以在它里面使用 HTML 定义 DOM 结构</p><h4 id="Shadow-DOM-规范"><a href="#Shadow-DOM-规范" class="headerlink" title="Shadow DOM 规范"></a>Shadow DOM 规范</h4><p>首先实例化一个根节点，挂在到宿主上，这里的宿主是 this。上面说过 this 指向 user-card。</p><p>然后我们把创建的 DOM 结构，或者<code>&lt;template&gt;</code>结构挂载到影子根上即可。看一下 HTML 结构展示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> shadow = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> &#125;);<br>shadow.<span class="hljs-title function_">appendChild</span>(content);<br></code></pre></td></tr></table></figure><h3 id="Exparser-框架原理"><a href="#Exparser-框架原理" class="headerlink" title="Exparser 框架原理"></a>Exparser 框架原理</h3><p>Exparser 是微信小城的组件组织框架，内置在小程序基础库中，为小程序提供各种各样的组件支撑<br>内置组件和自定义组件都由 Exparser 框架组织管理</p><p>Exparser 组件模型与 WebComponents 标准中的 Shadow DOM 高度相似</p><p>Exparser 会维护整个页面的节点树相关信息，包括节点的属性，事件绑定等，相当于一个简化版的 Shadow DOM 实现。Exparser 的主要特点包括如下:</p><ul><li>基于 Shadow DOM 模型: 模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他 API 以支持小程序组件编程。</li><li>可在纯 JS 环境中运行: 这意味着逻辑层也具有一定的组件树组织能力。</li><li>高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</li></ul><p>小程序中，所有节点树相关的操作都依赖于 Exparser，包括 WXML 到页面最终节点树的构建和自定义组件特性等。</p><h3 id="rpx-px"><a href="#rpx-px" class="headerlink" title="rpx -&gt; px"></a>rpx -&gt; px</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// px = rpx 值 / 基础设备宽度 750 * 设备宽度</span><br>number = (number / <span class="hljs-variable constant_">BASE_DEVICE_WIDTH</span>) * (newDeviceWidth || deviceWidth);<br></code></pre></td></tr></table></figure><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li><p>最开始在 wxml 文件中定义的事件绑定，其实转化成虚拟 dom 树结构之后，其实只是一个键值对，表明了某个 dom 上有绑定某个事件，并没有完成事件绑定。</p></li><li><p><code>WAWebview.js</code> 处理虚拟 dom 树时，会去循环遍历 attr 属性，判断 attr 中的属性名是否为事件属性</p></li><li><p>如果是，通过 <code>addListener</code> 方法进行了事件绑定。可以理解成，通过 addListener 方法监听 tap 事件，就相当于 window.addEventListener 对 mouseup 方法的监听。回调函数中对函数的 event 信息进行组装，并触发 sendData 方法。sendData 方法就是向逻辑线程发送 event 数据的方法。</p></li></ul><img src="/2023/09/06/mini-program/event.png" class="" title="event"><blockquote><p>目前在触发 sendData 方法之前这些逻辑的解析包括 event 参数的组装都是在渲染层的底层基础库 WAWebview.js 中完成的，也就是说还在渲染线程中。</p></blockquote><h3 id="通讯系统设计"><a href="#通讯系统设计" class="headerlink" title="通讯系统设计"></a>通讯系统设计</h3><p>最上面提到，视图层和逻辑层通讯是通过 Native 层。</p><p>具体的手段就是</p><p>ios 利用 WKWebView 的提供 messageHandlers 特性<br>android 是往 webview 的 window 对象注入一个原生方法<br>这两种会统一封装成 weixinJSBridge，这和正常 h5 与客户端通讯手段一致</p><p>初始化过程中 Native 层理论上是微信客户端，分别在视图层和业务逻辑层注入了 WeixinJSBridge</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>逻辑层的 data 与 view 是相互绑定的，data 是页面第一次渲染使用的初始数据。页面加载的时候，data 将会以 JSON 字符串形式由逻辑层传至渲染层。因此 data 中的数据必须是可以转成 JSON 的类型：字符串，数字，布尔值，对象，数组。</p><p>渲染层发出信号，发出一个我已经初始化完毕的信号发给逻辑层，并且自身状态进入等待。</p><p>逻辑层收到这个信号的时候有两种情况。</p><p>第一种就是自身还没初始化完，那么收到此信号后只需要初始化完毕后发送初始数据 Data 到渲染层即可。<br>第二种情况就是逻辑层早已经进入等待状态，那么收到信号后立即发送初始数据 Data 到渲染层即可。</p><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><code>onLoad(query:Object)</code>: 页面加载时触发，一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。</li><li><code>onShow()</code>: 页面显示&#x2F;切入前台时触发</li><li><code>onHide()</code>: 页面隐藏&#x2F;切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等</li><li><code>onReady()</code>: 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。</li><li><code>onUnload()</code>: 页面卸载时触发。如 wx.redirectTo 或 wx.navigateBack 到其他页面时</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://cloud.tencent.com/developer/article/2142622">微信小程序底层框架实现原理｜万字长文</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>mini-program</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2023/09/05/http/"/>
    <url>/2023/09/05/http/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="http1、http2"><a href="#http1、http2" class="headerlink" title="http1、http2"></a>http1、http2</h2><p>相对于 http1.0 http1.1 的优化：</p><ul><li><p>缓存处理：多了 Entity tag，if-Unmodified-since,if-Match,if-None-Match 等缓存信息（http1.0 if-modified-since, expires）</p></li><li><p>带宽优化及网络连接的使用</p></li><li><p>错误通知的管理</p></li><li><p>Host 头处理，针对多虚拟机在同一物理主机情况</p></li><li><p>长连接 http1.1 默认开启<code>Connection： keep-alive</code>,一定程度上摸不了 http1.0 每次请求都要创建连接的缺点</p></li></ul><p>相对于 http1.1，http2 的优化：</p><ul><li>http2 支持二进制传送，http1 是字符串传送</li><li>http2 支持多路复用</li><li>http2 采用 HPACK 压缩算法压缩头部，减少了传输体积</li><li>http2 支持服务端推送</li></ul><h2 id="http-与-https"><a href="#http-与-https" class="headerlink" title="http 与 https"></a>http 与 https</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><blockquote><p>http 优点</p></blockquote><ul><li><p>灵活可扩展。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，<br>还可以传输图片，视频等任意数据</p></li><li><p>请求-应答模式</p></li><li><p>可靠传送 HTTP 是基于 TCP&#x2F;IP，因此把这一特性继承了下来。</p></li><li><p>无状态</p></li></ul><blockquote><p>http 缺点</p></blockquote><ul><li>无状态。无法保存信息</li><li>明文传输，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让 HTTP 的报文信息暴露给了外界，给攻击者带来了便利</li><li>队头阻塞，当 http 开启长连接时，共用一个 TCP 连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。</li></ul><h2 id="http-报文结构"><a href="#http-报文结构" class="headerlink" title="http 报文结构"></a>http 报文结构</h2><img src="/2023/09/05/http/http-header.png" class="" title="http-header"><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS&#x2F;SSL 协议组合而成，而安全性的保证正是 SSL&#x2F;TLS 所做的工作。</p><blockquote><p>区别</p></blockquote><ul><li>http 是明文传输协议，https 协议是有 ssl+http 协议构建的可进行加密传输、身份认证的网络协议</li><li>https 比 http 更加安全，对搜索引擎更友好，利于 seo，谷歌百度优先索引 https 网页</li><li>https 标准端口 443，http 端口 80</li><li>https 需要用到 ssl 证书，而 http 不用</li></ul><h2 id="https-如何实现安全加密传输"><a href="#https-如何实现安全加密传输" class="headerlink" title="https 如何实现安全加密传输"></a>https 如何实现安全加密传输</h2><ul><li>客户端发起请求，链接到服务器 443 端口</li><li>服务器的证书（自己制作或向三方机构申请），自己制作的证书需要客户端验证通过。证书中包含了两个密钥，一个公钥一个密钥</li><li>服务端将公钥返回客户端，公钥包含了证书颁发机构，证书过期时间等信息</li><li>客户端收到公钥后，通过 ssl&#x2F;tsl 层首先对公钥信息进行验证，如颁发机构过期时间等。如果发现异常，则会弹出一个警告框，提示证书存在问题。否则就生成一个随机值，然后使用公钥对此随机值进行加密，此加密信息只能通过服务端的私钥才能解密获取生成的随机值。</li><li>服务端获取到加密信息后使用私钥解密获得随机值，以后服务端和客户端的通讯都会使用此随机值进行加密，而这个时候，只有服务端和客户端才知道这个随机值（私钥），服务端将要返回给客户端的数据通过随机值加密后返回。</li><li>客户端用之前生成的随机值解密服务端传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</li></ul><h2 id="http-与-tcp-的区别与联系"><a href="#http-与-tcp-的区别与联系" class="headerlink" title="http 与 tcp 的区别与联系"></a>http 与 tcp 的区别与联系</h2><ul><li><strong>TCP 是底层通讯协议</strong>，定义的是数据传输和连接方式的规范</li><li><strong>HTTP 是应用层协议</strong>，定义的是传输数据的内容的规范</li><li>HTTP 协议中的数据是利用 TCP 协议传输的，所以支持 HTTP 也就一定支持 TCP</li><li>HTTP 支持的是 www 服务</li><li>而 HTTP&#x2F;IP 是协议是 Internet 国际互联网络的基础。TCP&#x2F;IP 是网络中使用的基本的通信协议。</li></ul><h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><p><strong>建立起一个 TCP 连接需要经过三次握手</strong></p><p>第一次握手：客户端发送 syn 包(syn&#x3D;j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；</p><p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack&#x3D;j+1），同时自己也发送一个 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</p><p>第三次握手：客户端收到服务器的 SYN ＋ ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）</p><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><p>HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p><p>1）在 HTTP 1.0 中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p><p>2）在 HTTP 1.1 中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p><p>由于 HTTP 在每次请求结束后都会主动释放连接，因此 HTTP 连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>websocket 同 http 一样也是应用层的协议，但是它是一种双向通信协议，是建立在 tcp 之上的</p><p>websocket 是一种在单个 TCP 连接上进行双全工通信的协议</p><p>websocket 是的客户端和服务端之间的数据交换变得简单，允许服务端主动想客户端推送数据。浏览器和服务器只需要完成一次握手，两者直接就直接可以创建持久性的连接，并进行双向数据传输</p><p>websocket 默认使用请求协议为 ws:&#x2F;&#x2F;,默认端口 80.对 tls 加密请求协议为 wss:&#x2F;&#x2F; 端口为 443.</p><p>可以发送⽂本，也可以⼆进制⽂件。</p><h2 id="协议-分层"><a href="#协议-分层" class="headerlink" title="协议-分层"></a>协议-分层</h2><blockquote><p>TCP&#x2F;IP 它并不特指单纯的 TCP 和 IP 协议，而是容纳了许许多多的网络协议。</p></blockquote><h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>IP 是 互联网协议(Internet Protocol) ，位于网络层。IP 是整个 TCP&#x2F;IP 协议族的核心，也是构成互联网的基础。IP 能够为运输层提供数据分发，同时也能够组装数据供运输层使用。它将多个单个网络连接成为一个互联网，这样能够提高网络的可扩展性，实现大规模的网络互联。二是分割顶层网络和底层网络之间的耦合关系。</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 就是 传输控制协议，也就是 Transmission Control Protocol，它是一种面向连接的、可靠的、基于字节流的传输协议，TCP 协议位于传输层，TCP 协议是 TCP&#x2F;IP 协议簇中的核心协议，它最大的特点就是提供可靠的数据交付。</p><p>TCP 的主要特点有 慢启动、拥塞控制、快速重传、可恢复。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 协议就是 用户数据报协议，也就是 User Datagram Protocol，UDP 也是一种传输层的协议，与 TCP 相比，UDP 提供一种不可靠的数据交付，也就是说，UDP 协议不保证数据是否到达目标节点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 是一种无连接的协议，传输数据之前源端和终端无需建立连接，不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序等现象。但是 UDP 具有较好的实时性，工作效率较 TCP 协议高。</p><h3 id="FTP-协议"><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h3><p>FTP 协议是 文件传输协议，英文全称是 File Transfer Protocol，应用层协议之一，是 TCP&#x2F;IP 协议的重要组成之一，FTP 协议分为服务器和客户端两部分，FTP 服务器用来存储文件，FTP 客户端用来访问 FTP 服务器上的文件，FTP 的传输效率比较高，所以一般使用 FTP 来传输大文件。</p><h2 id="OSI-标准模型"><a href="#OSI-标准模型" class="headerlink" title="OSI 标准模型"></a>OSI 标准模型</h2><img src="/2023/09/05/http/osi.png" class="" title="osi"><h3 id="tcp-ip-协议中四个层次"><a href="#tcp-ip-协议中四个层次" class="headerlink" title="tcp&#x2F;ip 协议中四个层次"></a>tcp&#x2F;ip 协议中四个层次</h3><p>应用层 传输层 网络层 通信链路层</p><h3 id="各个分层的主要作用"><a href="#各个分层的主要作用" class="headerlink" title="各个分层的主要作用"></a>各个分层的主要作用</h3><p><strong>应用层</strong>：应用层是 OSI 标准模型的最顶层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。包括文件传输、电子邮件远程登录和远端接口调用等协议。</p><p><strong>表示层</strong>: 表示层向上对应用进程服务，向下接收会话层提供的服务，表示层位于 OSI 标准模型的第六层，表示层的主要作用就是将设备的固有数据格式转换为网络标准传输格式。</p><p><strong>会话层</strong>：会话层位于 OSI 标准模型的第五层，它是建立在传输层之上，利用传输层提供的服务建立和维持会话。</p><p><strong>传输层</strong>：传输层位于 OSI 标准模型的第四层，它在整个 OSI 标准模型中起到了至关重要的作用。传输层涉及到两个节点之间的数据传输，向上层提供可靠的数据传输服务。传输层的服务一般要经历传输连接建立阶段，数据传输阶段，传输连接释放阶段 3 个阶段才算完成一个完整的服务过程。</p><p><strong>网络层</strong>：网络层位于 OSI 标准模型的第三层，它位于传输层和数据链路层的中间，将数据设法从源端经过若干个中间节点传送到另一端，从而向运输层提供最基本的端到端的数据传送服务。</p><p><strong>数据链路层</strong>：数据链路层位于物理层和网络层中间，数据链路层定义了在单个链路上如何传输数据。</p><p><strong>物理层</strong>：物理层是 OSI 标准模型中最低的一层，物理层是整个 OSI 协议的基础，就如同房屋的地基一样，物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。</p><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存</title>
    <link href="/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>浏览器缓存分为<code>强缓存</code>和<code>协商缓存</code>。</p><p>先从 <b>http header</b> 判断是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器。</p><p>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 <b>request header</b> 验证这个资源是否命中协商缓存，称为 <code>http 再验证</code>。如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源。</p><p>强缓存和协商缓存的共同之处在于，如果命中换成，服务器都不会返回资源；</p><p>区别是强缓存不发送请求到服务器，而协商缓存会。</p><p>当协商缓存也没命中时，服务器就会讲资源发送到客户端</p><p>当按下 <font color="#54FF9F">ctrl+F5</font> 时，跳过强缓存和协商缓存，直接从服务器加载资源</p><p>当 <font color="#54FF9F">F5</font> 刷新网页时，跳过强缓存，但是会检查协商缓存</p><hr><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="强缓存的规则"><a href="#强缓存的规则" class="headerlink" title="强缓存的规则"></a>强缓存的规则</h3><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>优先级比<code>Expires</code>高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h3><p>该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间。值为服务器返回改请求结果缓存的到期时间，即再次发起请求时，如果客户端的时间小于 <code>Expires</code> 的值时，直接使用缓存结果。</p><h3 id="Cache-Control-max-age"><a href="#Cache-Control-max-age" class="headerlink" title="Cache-Control:max-age"></a><code>Cache-Control:max-age</code></h3><p>该字段是 http1.1 的规范，作为替换 <code>expires</code>。强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期。</p><p>取值为：</p><ul><li>public 所有内容都被换成（客户端和代理服务器都可以缓存）</li><li>private 所有内容只有客户端可以缓存，<code>Cache-control</code> 默认取值</li><li>no-cache 客户端缓存内容 但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store 所有内容都不会缓存，即不使用强制缓存也不使用协商缓存</li><li>max-age&#x3D;xxx 缓存内容将在 xxx 秒后失效</li></ul><blockquote><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p></blockquote><p>Status 状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size 值则代表该缓存存放的位置，分别为 <code>from memory cache</code> 和 <code>from disk cache</code>。</p><p><code>from memory cache</code> 代表使用内存中的缓存，<code>from disk cache</code> 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –&gt; disk。</p><p>内存缓存(from memory cache)和硬盘缓存(from disk cache)差异：</p><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</p><p>快速读取： 内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以便下次运行使用时快速读取</p><p>时效性： 一旦进程关闭，该进程的内存就会被清空</p><p>硬盘缓存： 硬盘缓存是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 IO 操作，然后重新解析改内存内容，速度慢。</p><p>在浏览器中，浏览器会在 <code>js</code> 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 <code>css</code> 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><blockquote><p>last-modified 缺点</p></blockquote><p><code>Last-Modified</code> 也有它的缺点，比如修改时间是 GMT 时间，只能精确到秒，如果文件在 1 秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件。而且如果文件被修改后又撤销修改了，内容还是保持原样，但是最后修改时间变了，也要重新请求。也有可能存在服务器没有准确获取文件修改时间，或与代理服务器时间不一致的情况。</p><p>为了解决文件修改时间不精确带来的问题，服务器和浏览器再次协商，这次不返回时间，返回文件的唯一标识<code>ETag</code>。只有当文件内容改变时，<code>ETag</code>才改变。<code>ETag</code>的优先级高于<code>Last-Modified</code>。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效 状态码返回 304</p><img src="/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/1.png" class="" title="协商缓存生效"><p>协商缓存失效，返回 200 和请求结果结果，如下:</p><img src="/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/2.png" class="" title="协商缓存失效"><p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code>和 <code>Etag / If-None-Match</code>，其中 <code>ETag / If-None-Match</code> 的优先级比<code>Last-Modified / If-Modified-Since</code>高。</p><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F; If-Modified-Since"></a><code>Last-Modified</code>&#x2F; <code>If-Modified-Since</code></h3><p>值为资源最后的更新时间，随服务器 response 返回。</p><p><code>Last-Modified</code> 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p><p><code>If-Modified-Since</code>则是客户端再次发起请求时，携带上次请求返回的 Last-Modified 值,通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有<code>If-Modified-Since</code>字段，则会根据<code>If-Modified-Since</code>字段值与该资源在服务器上的最后被修改时间做比对，若服务器最后被修改时间大于<code>If-Modified-Since</code>字段值，则返回资源，状态码为 200。否则返回 304，代表资源没有更新继续使用缓存文件。</p><h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag &#x2F; If-None-Match"></a><code>ETag</code> &#x2F; <code>If-None-Match</code></h3><p>ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p><code>If-None-Match</code>是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>ETag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>ETag</code>值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。<br>在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。</p><p>webpack 可以让我们在打包的时候，在文件的命名上带上 hash 值</p><p>我们可以得出一个较为合理的缓存方案：</p><p>HTML：使用协商缓存。<br>CSS&amp;JS&amp;图片：使用强缓存，文件命名带上 hash 值。</p><p>1、index.html 不做缓存，每次请求都获取最新版本<br>2、使用 webpack 等 build 后的其他所有资源文件（包括 js、css 和图片等），都做强缓存（一个月打底，可以设置一年）</p>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>browser</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包（closure）</title>
    <link href="/2023/09/04/closure/"/>
    <url>/2023/09/04/closure/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>闭包</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/17/hello-world/"/>
    <url>/2023/08/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AMD &amp;&amp; CMD &amp;&amp; CommonJs &amp;&amp; UMD &amp;&amp; ES</title>
    <link href="/2023/08/17/umd&amp;amd&amp;es&amp;cjs/"/>
    <url>/2023/08/17/umd&amp;amd&amp;es&amp;cjs/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><span class="hint--info hint--rounded hint--top" data-hint="Asynchronous Module Definition" ontouchstart>AMD</span> 是一种异步模块加载规范，专为浏览器设计。全称是 Asynchronous Module Definition,中文名称是异步模块定义。<p>提供定义模块及异步加载该模块依赖的机制，这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载会导致性能，可用性，调试和跨域访问等问题）。但浏览器并不支持 AMD 模块，在浏览器端，需要借助 RequireJS 才能加载 AMD 模块。</p><p>AMD 规范中定义模块的的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(id?: <span class="hljs-title class_">String</span>, dependencies?: <span class="hljs-title class_">String</span>[], <span class="hljs-attr">factory</span>: <span class="hljs-title class_">Function</span>|<span class="hljs-title class_">Object</span>);<br></code></pre></td></tr></table></figure><p><code>id</code>: 模块的名称是个字符串，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p><p>模块名的格式：模块名用来唯一标识定义中模块，它们同样在依赖数组中使用。AMD 的模块名规范是 CommonJS 模块名规范的超集。引用如下：</p><ul><li>模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串</li><li>单词须为驼峰形式，或者”.”，”..”</li><li>模块名不允许文件扩展名的形式，如”.js”</li><li>模块名可以为 “相对的” 或 “顶级的”。如果首字符为”.”或”..”则为”相对的”模块名</li><li>顶级的模块名从根命名空间的概念模块解析</li><li>相对的模块名从 “require” 书写和调用的模块解析</li><li>上面所说到的 CommonJS 模块 id 属性常被用于 JavaScript 模块。</li></ul><p>相对模块名解析示例：</p><ul><li>如果模块 “a&#x2F;b&#x2F;c” 请求 “..&#x2F;d”, 则解析为”a&#x2F;d”</li><li>如果模块 “a&#x2F;b&#x2F;c” 请求 “.&#x2F;e”, 则解析为”a&#x2F;b&#x2F;e”</li></ul><p><code>dependencies</code>: 是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;&#125;）<br></code></pre></td></tr></table></figure><p><code>factory</code>: 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p><p>AMD 模块使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;模块名&quot;</span>], callback);<br></code></pre></td></tr></table></figure><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>通用模块定义，其提供了模块定义和按需加载执行模块。它解决的问题和 AMD 规范是一样的，只不过在模块定义方式和模块加载时机上不同，CMD 也需要额外的引入第三方的库文件，SeaJS,SeaJS 推崇一个模块一个文件</p><p>在 CMD 规范中，一个文件就是一个模块，使用 define 来进行定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(factory);<br></code></pre></td></tr></table></figure><p>这里的 define 是一个全局函数，用来定义模块，这里的 factory 参数既可以是函数，又可以是字符串或对象。如果参数是字符串或对象时，表示该模块的接口就是该对象或字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(&#123; <span class="hljs-attr">website</span>: <span class="hljs-string">&quot;oecom&quot;</span> &#125;);<br><span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;这里是OECOM&quot;</span>);<br></code></pre></td></tr></table></figure><p>当 factory 为函数时，此函数就是模块的构造方法，该函数默认为提供三个参数：require,exports,module</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;&#125;);<br></code></pre></td></tr></table></figure><p>– <strong><code>require</code></strong> –</p><ul><li>同步加载</li></ul><p>require 参数也是一个方法，接收的参数为模块标识，其实就是需要加载模块的相对路径，作用就是加载其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);<br>  a.<span class="hljs-title function_">out</span>(); <span class="hljs-comment">//假设模块a有out方法。</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>异步加载<br>直接使用 require 加载属于是同步加载，require 提供了 async 方法来在模块内部进行异步加载模块，并在加载完成以后执行指定的回调函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-built_in">require</span>.<span class="hljs-title function_">async</span>(<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    a.<span class="hljs-title function_">doSomething</span>();<br>  &#125;);<br><br>  <span class="hljs-built_in">require</span>.<span class="hljs-title function_">async</span>([<span class="hljs-string">&quot;./c&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params">c, b</span>) &#123;<br>    c.<span class="hljs-title function_">doSomething</span>();<br>    b.<span class="hljs-title function_">doSomething</span>();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>require</code> 是同步往下执行，<code>require.async</code> 则是异步回调执行。<code>require.async</code> 一般用来加载可延迟异步加载的模块。</p><ul><li>获取模块路径<br>require.resolve 使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。</li></ul><p>– <strong><code>exports</code></strong> –</p><p>exports 是一个用来想外接提供模块接口的对象</p><p>提示：exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。</p><p>还有一点就是导出模块不要写在回调函数里，导出是需要同步执行，否则导入是会导入失败。</p><h2 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js 中采用此规范，每一个文件就是一个模块，有自己的作用域，模块中的变量，函数，类都是私有的。</p><p>CommonJS 规范规定，每个模块内部，<code>module</code>变量代表当前模块。这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</p><p>使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模块</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> addX = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> value + x;<br>&#125;;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">x</span> = x;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">addX</span> = addX;<br></code></pre></td></tr></table></figure><p>CommonJS 模块的特点如下：</p><blockquote><p>所有代码都运行在模块作用域，不会污染全局作用域。<br>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>模块加载的顺序，按照其在代码中出现的顺序。</p></blockquote><h3 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h3><p>所有模块都是<code>Module</code>的实例。每个模块内部都有一个 module 对象，代表当前模块。有如下属性：</p><ul><li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li><li><code>module.filename</code> 模块的文件名，带有绝对路径。</li><li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li><li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li><li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li><li><code>module.exports</code> 表示模块对外输出的值。</li></ul><h4 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h4><p><code>module.exports</code>属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取<code>module.exports</code>变量。</p><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>为了方便，Node 为每个模块提供一个<code>exports</code>变量，指向<code>module.exports</code>。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;<br></code></pre></td></tr></table></figure><p>在对外输出模块接口时，可以向 exports 对象添加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&quot;Hello world&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，hello 函数是无法对外输出的，因为 module.exports 被重新赋值了。</p><p>这意味着，<strong>如果一个模块的对外接口，就是一个单一的值，不能使用 exports 输出，只能使用 module.exports 输出</strong>。</p><h3 id="AMD-与-CJS-的兼容性"><a href="#AMD-与-CJS-的兼容性" class="headerlink" title="AMD 与 CJS 的兼容性"></a>AMD 与 CJS 的兼容性</h3><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p><h3 id="require-命令"><a href="#require-命令" class="headerlink" title="require 命令"></a>require 命令</h3><p>模块的循环加载</p><p>如果发生模块的循环加载，即 A 加载 B，B 又加载 A，则 B 将加载 A 的不完整版本。</p><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p><p><strong>require 的内部处理流程</strong></p><p>require 指向当前模块的 module.require，而后者又调用 Node 内部命令 Module._load</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Module</span>.<span class="hljs-property">_load</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">request, parent, isMain</span>) &#123;<br>  <span class="hljs-comment">// 1. 检查Module._cache， 是否缓存中存在此模块</span><br>  <span class="hljs-comment">// 2. 如果缓存中不存在，就创建新的Module实例</span><br>  <span class="hljs-comment">// 3. 添加到缓存</span><br>  <span class="hljs-comment">// 4. 使用module.load()加载指定的模块文件,读取文件之后，使用module.compile()执行文件代码</span><br>  <span class="hljs-comment">// 5. 如果加载/解析报错，就从缓存中删除此模块</span><br>  <span class="hljs-comment">// 6. 返回模块的module.exports</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>通用模块加载规范</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">root, factory</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span> === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;是commonjs模块规范，nodejs环境&quot;</span>);<br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;是AMD模块规范，如require.js&quot;</span>);<br>    <span class="hljs-title function_">define</span>(<span class="hljs-title function_">factory</span>());<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; define.<span class="hljs-property">cmd</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;是CMD模块规范，如sea.js&quot;</span>);<br>    <span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>      <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;没有模块环境，直接挂载在全局对象上&quot;</span>);<br>    root.<span class="hljs-property">umdModule</span> = <span class="hljs-title function_">factory</span>();<br>  &#125;<br>&#125;)(<span class="hljs-variable language_">this</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;我是一个umd模块&quot;</span>,<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><p>ES Modules 特性<br>给 script 标签 设置<code>type = module</code> 来告知当前 script 标签中的代码采用 ESM 的规范来执行</p><ul><li>自动采用严格模式</li><li>每个 ESM 模块都是单独的私有作用域</li><li>ESM 的 script 标签会延迟执行脚本，默认加上了 defer 属性</li><li>ESM 是通过 CORS 这种跨域请求的方式 去请求外部 JS 模块的</li></ul><p><strong>export 导出是栈内存中的变量（原始数据类型存储的是值，对象数据类型存储的是堆内存的引用地址）</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
