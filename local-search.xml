<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器事件循环机制</title>
    <link href="/2023/09/06/event-loop/"/>
    <url>/2023/09/06/event-loop/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小程序</title>
    <link href="/2023/09/06/mini-program/"/>
    <url>/2023/09/06/mini-program/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="unionid-openid"><a href="#unionid-openid" class="headerlink" title="unionid &amp; openid"></a>unionid &amp; openid</h3><h4 id="unionid"><a href="#unionid" class="headerlink" title="unionid"></a>unionid</h4><p>unionid 是一个用户对应同主体微信小程序&#x2F;公众号&#x2F;app 的标识，开发者需要再微信开放平台下绑定相同账号的主体。开发者可以通过 UnionId,实现多个小程序、公众号甚至 app 之间数据互通</p><h4 id="openid"><a href="#openid" class="headerlink" title="openid"></a>openid</h4><p>openid 是一个用户对于一个小程序&#x2F;公众号的标识，开发者可以通过这个标识识别出用户</p><h3 id="登录流程设计"><a href="#登录流程设计" class="headerlink" title="登录流程设计"></a>登录流程设计</h3><ol><li><p>利用现有的登录体系<br>直接复用现有系统的登录体系， 只需要在小程序端设计用户名，密码&#x2F;验证码输<br>⼊页面，便可以简便的实现登录， 只需要保持良好的用户体验即可</p></li><li><p>利用 OpenId 创建用户体系<br>OpenId 是⼀个⼩程序对于⼀个用户的标识，利用这⼀点我们可以轻松的实<br>现⼀套基于⼩程序的用户体系，值得⼀提的是这种用户体系对用户的打扰最<br>低， 可以实现静默登录 。具体步骤如下：</p><ul><li>小程序客户端通过 <code>wx.login</code> 获取 <code>code</code></li><li>传递 <code>code</code> 向服务端，服务端拿到 <code>code</code> 调用微信登录凭证校验接口，微信服务器返回 <code>openId</code> 和会话密钥 <code>session_key</code>，此时开发者服务端可以利用 <code>openid</code> 生成用户入库，再向小程序客户端返回自定义登录态</li><li>小程序客户端缓存自定义登录态（token），后续调用 api 携带此 token</li></ul></li><li><p>利用 unionId 创建用户体系</p></li></ol><ul><li><p>如果户关注了某个相同主体公众号， 或曾经在某个相同主体 App 、公众号上进行过微信登<br>录授权， 通过 wx.login 可以直接获取 到 unionid</p></li><li><p>结合 wx.getUserInfo 和 <code>&lt;button open-type=&quot;getUserInfo&quot;&gt;&lt;button/&gt;</code> 这两种⽅式引导用户主动授权， 主动授权后通过返回的信息和服务端交互 (这里有⼀步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录。<br>具体示例：</p><blockquote><ol><li>调用 <code>wx.login</code> 获取 <code>code</code> ，然后从微信后端换取到 <code>session_key</code> ，用于 解密<code>getUserInfo</code> 返回的敏感数据</li><li>使用 <code>wx.getSetting</code> 获取用户的授权情况</li><li>如果用户已经授权， 直接调用 API <code>wx.getUserInfo</code> 获取用户最新的信息；</li><li>用户未授权，在界面中显示⼀个按钮提示用户登⼊， 当用户点击并授权后就获取到用<br>户的最新信息</li><li>获取到用户数据后可以进行展示或者发送给自⼰的后端。</li></ol></blockquote></li></ul><h2 id="双线程模型"><a href="#双线程模型" class="headerlink" title="双线程模型"></a>双线程模型</h2><p>小程序的渲染层和逻辑层分别由两个线程管理：渲染层的界面使用 webView 进行渲染；逻辑层采用 jsCore 运行 js 代码。一个小程序存在多个界面，所以渲染层存在多个 webView。这两个线程间的通信有小程序 Native 侧中转，逻辑层发送网络请求也经由 Native 侧转发，小程序的通信模型为：</p><img src="/2023/09/06/mini-program/wechat-miniprogram-framework.png" class="" title="wechat-miniprogram"><p>微信小程序视图层是 WebView，逻辑层是 JS 引擎。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>Android</td><td>V8</td><td>Chromium 定制内核</td></tr><tr><td>iOS</td><td>jsCore</td><td>WKWebView</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><p>我们看一下单 WebView 实例与小程序双线程多实例代码执行的差异点</p><img src="/2023/09/06/mini-program/double-thread.png" class="" title="double-thread"><p>多 WebView 模式下，每一个 WebView 都有一个独立的 JSContext，虽然可以通过窗口通信实现数据传递，但是无法共享数据和方法，对于全局的状态管理也相对比较复杂，抽离一个通用的 WebView 或者 JS Engine 作为应用的 JSContext 就可以解决这些问题，但是同时引入了其他问题：视图和逻辑如何通信，在小程序里面数据更新后视图是异步更新的。</p><p>双线程交互的生命周期图示：</p><img src="/2023/09/06/mini-program/lifecycle.png" class="" title="lifecycle"><h2 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h2><p>小程序逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。</p><blockquote><p>iOS 通过 <strong><code>window.webkit.messageHandlers.invokeHandler.postMessage</code></strong> 来与 Native 通信<br>Android 通过 X5 内核的 <strong><code>window.WeixinJSCore.invokeHandler</code></strong> 来与 Native 通信</p></blockquote><h3 id="视图层组件"><a href="#视图层组件" class="headerlink" title="视图层组件"></a>视图层组件</h3><p>内置组件中有部分组件是利用到客户端原生提供的能量，既然需要客户端原生提供的能力，那就会涉及到视图层和客户端的交互通信。这层通信机制在 iOS 和安卓系统的实现方式并不一样。iOS 是利用了 WKWebView 提供的 messageHandlers 特性，安卓是往 WebView 的 window 对象上注入了一个原生方法，最终会被封装为 WeXinJSBridge 这样一个兼容层，主要提供调用（invoke）和监听（on）方法。</p><p>我们知道微信小程序逻辑层没有浏览器的 DOM&#x2F;BOM，视图层的更新借助于 Virtual DOM。用 JS 对象模拟 DOM 树 -&gt; 比较两棵虚拟 DOM 树的差异 -&gt; 把差异应用到真正的 DOM 树上，状态更新的时候，通过对比前后 JS 对象变化，进而改变视图层的 Dom 树。实际上，在视图层与客户端的交互通信中，开发者只是间接调用的，真正调用是在组件的内部实现中。开发者插入一个原生组件，一般而言，组件运行的时候被插入到 DOM 树中，会调用客户端接口，通知客户端在哪个位置渲染一块原生界面。在后续开发者更新组件属性时，同样地，也会调用客户端提供的更新接口来更新原生界面的某些部分。</p><h3 id="逻辑层接口"><a href="#逻辑层接口" class="headerlink" title="逻辑层接口"></a>逻辑层接口</h3><p>逻辑层与客户端原生通信机制与渲染层类似，不同在于，iOS 平台可以往 JavaScripCore 框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。</p><p>同样地，开发者也是间接地调用到与客户端原生通信的底层接口。一般我们会对逻辑层接口做层封装后才暴露给开发者，封装的细节可能是统一入参、做些参数校验、兼容各平台或版本问题等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>mini-program</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2023/09/05/http/"/>
    <url>/2023/09/05/http/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="http1、http2"><a href="#http1、http2" class="headerlink" title="http1、http2"></a>http1、http2</h2><p>相对于 http1.0 http1.1 的优化：</p><ul><li><p>缓存处理：多了 Entity tag，if-Unmodified-since,if-Match,if-None-Match 等缓存信息（http1.0 if-modified-since, expires）</p></li><li><p>带宽优化及网络连接的使用</p></li><li><p>错误通知的管理</p></li><li><p>Host 头处理</p></li><li><p>长连接 http1.1 默认开启<code>Connection： keep-alive</code>,一定程度上摸不了 http1.0 每次请求都要创建连接的缺点</p></li></ul><p>相对于 http1.1，http2 的优化：</p><ul><li>http2 支持二进制传送，http1 是字符串传送</li><li>http2 支持多路复用</li><li>http2 采用 HPACK 压缩算法压缩头部，减少了传输体积</li><li>http2 支持服务端推送</li></ul><h2 id="http-与-https"><a href="#http-与-https" class="headerlink" title="http 与 https"></a>http 与 https</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><blockquote><p>http 优点</p></blockquote><ul><li><p>灵活可扩展。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，<br>还可以传输图片，视频等任意数据</p></li><li><p>请求-应答模式</p></li><li><p>可靠传送 HTTP 是基于 TCP&#x2F;IP，因此把这一特性继承了下来。</p></li><li><p>无状态</p></li></ul><blockquote><p>http 缺点</p></blockquote><ul><li>无状态。无法保存信息</li><li>明文传输，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让 HTTP 的报文信息暴露给了外界，给攻击者带来了便利</li><li>队头阻塞，当 http 开启长连接时，共用一个 TCP 连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。</li></ul><h2 id="http-报文结构"><a href="#http-报文结构" class="headerlink" title="http 报文结构"></a>http 报文结构</h2><img src="/2023/09/05/http/http-header.png" class="" title="http-header"><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS&#x2F;SSL 协议组合而成，而安全性的保证正是 SSL&#x2F;TLS 所做的工作。</p><blockquote><p>区别</p></blockquote><ul><li>http 是明文传输协议，https 协议是有 ssl+http 协议构建的可进行加密传输、身份认证的网络协议</li><li>https 比 http 更加安全，对搜索引擎更友好，利于 seo，谷歌百度优先索引 https 网页</li><li>https 标准端口 443，http 端口 80</li><li>https 需要用到 ssl 证书，而 http 不用</li></ul><h2 id="https-如何实现安全加密传输"><a href="#https-如何实现安全加密传输" class="headerlink" title="https 如何实现安全加密传输"></a>https 如何实现安全加密传输</h2><ul><li>客户端发起请求，链接到服务器 443 端口</li><li>服务器的证书（自己制作或向三方机构申请），自己制作的证书需要客户端验证通过。证书中包含了两个密钥，一个公钥一个密钥</li><li>服务端将公钥返回客户端，公钥包含了证书颁发机构，证书过期时间等信息</li><li>客户端收到公钥后，通过 ssl&#x2F;tsl 层首先对公钥信息进行验证，如颁发机构过期时间等。如果发现异常，则会弹出一个警告框，提示证书存在问题。否则就生成一个随机值，然后使用公钥对此随机值进行加密，此加密信息只能通过服务端的私钥才能解密获取生成的随机值。</li><li>服务端获取到加密信息后使用私钥解密获得随机值，以后服务端和客户端的通讯都会使用此随机值进行加密，而这个时候，只有服务端和客户端才知道这个随机值（私钥），服务端将要返回给客户端的数据通过随机值加密后返回。</li><li>客户端用之前生成的随机值解密服务端传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</li></ul><h2 id="http-与-tcp-的区别与联系"><a href="#http-与-tcp-的区别与联系" class="headerlink" title="http 与 tcp 的区别与联系"></a>http 与 tcp 的区别与联系</h2><ul><li><strong>TCP 是底层通讯协议</strong>，定义的是数据传输和连接方式的规范</li><li><strong>HTTP 是应用层协议</strong>，定义的是传输数据的内容的规范</li><li>HTTP 协议中的数据是利用 TCP 协议传输的，所以支持 HTTP 也就一定支持 TCP</li><li>HTTP 支持的是 www 服务</li><li>而 HTTP&#x2F;IP 是协议是 Internet 国际互联网络的基础。TCP&#x2F;IP 是网络中使用的基本的通信协议。</li></ul><h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><p><strong>建立起一个 TCP 连接需要经过三次握手</strong></p><p>第一次握手：客户端发送 syn 包(syn&#x3D;j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；</p><p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack&#x3D;j+1），同时自己也发送一个 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</p><p>第三次握手：客户端收到服务器的 SYN ＋ ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）</p><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><p>HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p><p>1）在 HTTP 1.0 中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p><p>2）在 HTTP 1.1 中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p><p>由于 HTTP 在每次请求结束后都会主动释放连接，因此 HTTP 连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>websocket 同 http 一样也是应用层的协议，但是它是一种双向通信协议，是建立在 tcp 之上的</p><p>websocket 是一种在单个 TCP 连接上进行双全工通信的协议</p><p>websocket 是的客户端和服务端之间的数据交换变得简单，允许服务端主动想客户端推送数据。浏览器和服务器只需要完成一次握手，两者直接就直接可以创建持久性的连接，并进行双向数据传输</p><p>websocket 默认使用请求协议为 ws:&#x2F;&#x2F;,默认端口 80.对 tls 加密请求协议为 wss:&#x2F;&#x2F; 端口为 443.</p><p>可以发送⽂本，也可以⼆进制⽂件。</p><h2 id="协议-分层"><a href="#协议-分层" class="headerlink" title="协议-分层"></a>协议-分层</h2><blockquote><p>TCP&#x2F;IP 它并不特指单纯的 TCP 和 IP 协议，而是容纳了许许多多的网络协议。</p></blockquote><h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>IP 是 互联网协议(Internet Protocol) ，位于网络层。IP 是整个 TCP&#x2F;IP 协议族的核心，也是构成互联网的基础。IP 能够为运输层提供数据分发，同时也能够组装数据供运输层使用。它将多个单个网络连接成为一个互联网，这样能够提高网络的可扩展性，实现大规模的网络互联。二是分割顶层网络和底层网络之间的耦合关系。</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 就是 传输控制协议，也就是 Transmission Control Protocol，它是一种面向连接的、可靠的、基于字节流的传输协议，TCP 协议位于传输层，TCP 协议是 TCP&#x2F;IP 协议簇中的核心协议，它最大的特点就是提供可靠的数据交付。</p><p>TCP 的主要特点有 慢启动、拥塞控制、快速重传、可恢复。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 协议就是 用户数据报协议，也就是 User Datagram Protocol，UDP 也是一种传输层的协议，与 TCP 相比，UDP 提供一种不可靠的数据交付，也就是说，UDP 协议不保证数据是否到达目标节点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 是一种无连接的协议，传输数据之前源端和终端无需建立连接，不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序等现象。但是 UDP 具有较好的实时性，工作效率较 TCP 协议高。</p><h3 id="FTP-协议"><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h3><p>FTP 协议是 文件传输协议，英文全称是 File Transfer Protocol，应用层协议之一，是 TCP&#x2F;IP 协议的重要组成之一，FTP 协议分为服务器和客户端两部分，FTP 服务器用来存储文件，FTP 客户端用来访问 FTP 服务器上的文件，FTP 的传输效率比较高，所以一般使用 FTP 来传输大文件。</p><h2 id="OSI-标准模型"><a href="#OSI-标准模型" class="headerlink" title="OSI 标准模型"></a>OSI 标准模型</h2><img src="/2023/09/05/http/osi.png" class="" title="osi"><h3 id="tcp-ip-协议中四个层次"><a href="#tcp-ip-协议中四个层次" class="headerlink" title="tcp&#x2F;ip 协议中四个层次"></a>tcp&#x2F;ip 协议中四个层次</h3><p>应用层 传输层 网络层 通信链路层</p><h3 id="各个分层的主要作用"><a href="#各个分层的主要作用" class="headerlink" title="各个分层的主要作用"></a>各个分层的主要作用</h3><p><strong>应用层</strong>：应用层是 OSI 标准模型的最顶层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。包括文件传输、电子邮件远程登录和远端接口调用等协议。</p><p><strong>表示层</strong>: 表示层向上对应用进程服务，向下接收会话层提供的服务，表示层位于 OSI 标准模型的第六层，表示层的主要作用就是将设备的固有数据格式转换为网络标准传输格式。</p><p><strong>会话层</strong>：会话层位于 OSI 标准模型的第五层，它是建立在传输层之上，利用传输层提供的服务建立和维持会话。</p><p><strong>传输层</strong>：传输层位于 OSI 标准模型的第四层，它在整个 OSI 标准模型中起到了至关重要的作用。传输层涉及到两个节点之间的数据传输，向上层提供可靠的数据传输服务。传输层的服务一般要经历传输连接建立阶段，数据传输阶段，传输连接释放阶段 3 个阶段才算完成一个完整的服务过程。</p><p><strong>网络层</strong>：网络层位于 OSI 标准模型的第三层，它位于传输层和数据链路层的中间，将数据设法从源端经过若干个中间节点传送到另一端，从而向运输层提供最基本的端到端的数据传送服务。</p><p><strong>数据链路层</strong>：数据链路层位于物理层和网络层中间，数据链路层定义了在单个链路上如何传输数据。</p><p><strong>物理层</strong>：物理层是 OSI 标准模型中最低的一层，物理层是整个 OSI 协议的基础，就如同房屋的地基一样，物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。</p>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存</title>
    <link href="/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>浏览器缓存分为<code>强缓存</code>和<code>协商缓存</code>。</p><p>先从 <b>http header</b> 判断是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器。</p><p>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 <b>request header</b> 验证这个资源是否命中协商缓存，称为 <code>http 再验证</code>。如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源。</p><p>强缓存和协商缓存的共同之处在于，如果命中换成，服务器都不会返回资源；</p><p>区别是强缓存不发送请求到服务器，而协商缓存会。</p><p>当协商缓存也没命中时，服务器就会讲资源发送到客户端</p><p>当按下 <font color="#54FF9F">ctrl+F5</font> 时，跳过强缓存和协商缓存，直接从服务器加载资源</p><p>当 <font color="#54FF9F">F5</font> 刷新网页时，跳过强缓存，但是会检查协商缓存</p><hr><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="强缓存的规则"><a href="#强缓存的规则" class="headerlink" title="强缓存的规则"></a>强缓存的规则</h3><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>优先级比<code>Expires</code>高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h3><p>该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间。值为服务器返回改请求结果缓存的到期时间，即再次发起请求时，如果客户端的时间小于 <code>Expires</code> 的值时，直接使用缓存结果。</p><h3 id="Cache-Control-max-age"><a href="#Cache-Control-max-age" class="headerlink" title="Cache-Control:max-age"></a><code>Cache-Control:max-age</code></h3><p>该字段是 http1.1 的规范，作为替换 <code>expires</code>。强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期。</p><p>取值为：</p><ul><li>public 所有内容都被换成（客户端和代理服务器都可以缓存）</li><li>private 所有内容只有客户端可以缓存，<code>Cache-control</code> 默认取值</li><li>no-cache 客户端缓存内容 但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store 所有内容都不会缓存，即不使用强制缓存也不使用协商缓存</li><li>max-age&#x3D;xxx 缓存内容将在 xxx 秒后失效</li></ul><blockquote><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p></blockquote><p>Status 状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size 值则代表该缓存存放的位置，分别为 <code>from memory cache</code> 和 <code>from disk cache</code>。</p><p><code>from memory cache</code> 代表使用内存中的缓存，<code>from disk cache</code> 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –&gt; disk。</p><p>内存缓存(from memory cache)和硬盘缓存(from disk cache)差异：</p><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</p><p>快速读取： 内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以便下次运行使用时快速读取</p><p>时效性： 一旦进程关闭，该进程的内存就会被清空</p><p>硬盘缓存： 硬盘缓存是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 IO 操作，然后重新解析改内存内容，速度慢。</p><p>在浏览器中，浏览器会在 <code>js</code> 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 <code>css</code> 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><blockquote><p>last-modified 缺点</p></blockquote><p><code>Last-Modified</code> 也有它的缺点，比如修改时间是 GMT 时间，只能精确到秒，如果文件在 1 秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件。而且如果文件被修改后又撤销修改了，内容还是保持原样，但是最后修改时间变了，也要重新请求。也有可能存在服务器没有准确获取文件修改时间，或与代理服务器时间不一致的情况。</p><p>为了解决文件修改时间不精确带来的问题，服务器和浏览器再次协商，这次不返回时间，返回文件的唯一标识<code>ETag</code>。只有当文件内容改变时，<code>ETag</code>才改变。<code>ETag</code>的优先级高于<code>Last-Modified</code>。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效 状态码返回 304</p><img src="/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/1.png" class="" title="协商缓存生效"><p>协商缓存失效，返回 200 和请求结果结果，如下:</p><img src="/2023/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/2.png" class="" title="协商缓存失效"><p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code>和 <code>Etag / If-None-Match</code>，其中 <code>ETag / If-None-Match</code> 的优先级比<code>Last-Modified / If-Modified-Since</code>高。</p><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F; If-Modified-Since"></a><code>Last-Modified</code>&#x2F; <code>If-Modified-Since</code></h3><p>值为资源最后的更新时间，随服务器 response 返回。</p><p><code>Last-Modified</code> 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p><p><code>If-Modified-Since</code>则是客户端再次发起请求时，携带上次请求返回的 Last-Modified 值,通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有<code>If-Modified-Since</code>字段，则会根据<code>If-Modified-Since</code>字段值与该资源在服务器上的最后被修改时间做比对，若服务器最后被修改时间大于<code>If-Modified-Since</code>字段值，则返回资源，状态码为 200。否则返回 304，代表资源没有更新继续使用缓存文件。</p><h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag &#x2F; If-None-Match"></a><code>ETag</code> &#x2F; <code>If-None-Match</code></h3><p>ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p><code>If-None-Match</code>是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>ETag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>ETag</code>值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。<br>在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。</p><p>webpack 可以让我们在打包的时候，在文件的命名上带上 hash 值</p><p>我们可以得出一个较为合理的缓存方案：</p><p>HTML：使用协商缓存。<br>CSS&amp;JS&amp;图片：使用强缓存，文件命名带上 hash 值。</p><p>1、index.html 不做缓存，每次请求都获取最新版本<br>2、使用 webpack 等 build 后的其他所有资源文件（包括 js、css 和图片等），都做强缓存（一个月打底，可以设置一年）</p>]]></content>
    
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>browser</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包（closure）</title>
    <link href="/2023/09/04/closure/"/>
    <url>/2023/09/04/closure/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>闭包</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React cookbook</title>
    <link href="/2023/08/18/React-cookbook/"/>
    <url>/2023/08/18/React-cookbook/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/17/hello-world/"/>
    <url>/2023/08/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AMD &amp;&amp; CMD &amp;&amp; CommonJs &amp;&amp; UMD &amp;&amp; ES</title>
    <link href="/2023/08/17/umd&amp;amd&amp;es&amp;cjs/"/>
    <url>/2023/08/17/umd&amp;amd&amp;es&amp;cjs/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><span class="hint--info hint--rounded hint--top" data-hint="Asynchronous Module Definition" ontouchstart>AMD</span> 是一种异步模块加载规范，专为浏览器设计。全称是 Asynchronous Module Definition,中文名称是异步模块定义。<p>提供定义模块及异步加载该模块依赖的机制，这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载会导致性能，可用性，调试和跨域访问等问题）。但浏览器并不支持 AMD 模块，在浏览器端，需要借助 RequireJS 才能加载 AMD 模块。</p><p>AMD 规范中定义模块的的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(id?: <span class="hljs-title class_">String</span>, dependencies?: <span class="hljs-title class_">String</span>[], <span class="hljs-attr">factory</span>: <span class="hljs-title class_">Function</span>|<span class="hljs-title class_">Object</span>);<br></code></pre></td></tr></table></figure><p><code>id</code>: 模块的名称是个字符串，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p><p>模块名的格式：模块名用来唯一标识定义中模块，它们同样在依赖数组中使用。AMD 的模块名规范是 CommonJS 模块名规范的超集。引用如下：</p><ul><li>模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串</li><li>单词须为驼峰形式，或者”.”，”..”</li><li>模块名不允许文件扩展名的形式，如”.js”</li><li>模块名可以为 “相对的” 或 “顶级的”。如果首字符为”.”或”..”则为”相对的”模块名</li><li>顶级的模块名从根命名空间的概念模块解析</li><li>相对的模块名从 “require” 书写和调用的模块解析</li><li>上面所说到的 CommonJS 模块 id 属性常被用于 JavaScript 模块。</li></ul><p>相对模块名解析示例：</p><ul><li>如果模块 “a&#x2F;b&#x2F;c” 请求 “..&#x2F;d”, 则解析为”a&#x2F;d”</li><li>如果模块 “a&#x2F;b&#x2F;c” 请求 “.&#x2F;e”, 则解析为”a&#x2F;b&#x2F;e”</li></ul><p><code>dependencies</code>: 是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;&#125;）<br></code></pre></td></tr></table></figure><p><code>factory</code>: 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p><p>AMD 模块使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;模块名&quot;</span>], callback);<br></code></pre></td></tr></table></figure><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>通用模块定义，其提供了模块定义和按需加载执行模块。它解决的问题和 AMD 规范是一样的，只不过在模块定义方式和模块加载时机上不同，CMD 也需要额外的引入第三方的库文件，SeaJS,SeaJS 推崇一个模块一个文件</p><p>在 CMD 规范中，一个文件就是一个模块，使用 define 来进行定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(factory);<br></code></pre></td></tr></table></figure><p>这里的 define 是一个全局函数，用来定义模块，这里的 factory 参数既可以是函数，又可以是字符串或对象。如果参数是字符串或对象时，表示该模块的接口就是该对象或字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(&#123; <span class="hljs-attr">website</span>: <span class="hljs-string">&quot;oecom&quot;</span> &#125;);<br><span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;这里是OECOM&quot;</span>);<br></code></pre></td></tr></table></figure><p>当 factory 为函数时，此函数就是模块的构造方法，该函数默认为提供三个参数：require,exports,module</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;&#125;);<br></code></pre></td></tr></table></figure><p>– <strong><code>require</code></strong> –</p><ul><li>同步加载</li></ul><p>require 参数也是一个方法，接收的参数为模块标识，其实就是需要加载模块的相对路径，作用就是加载其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);<br>  a.<span class="hljs-title function_">out</span>(); <span class="hljs-comment">//假设模块a有out方法。</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>异步加载<br>直接使用 require 加载属于是同步加载，require 提供了 async 方法来在模块内部进行异步加载模块，并在加载完成以后执行指定的回调函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-built_in">require</span>.<span class="hljs-title function_">async</span>(<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    a.<span class="hljs-title function_">doSomething</span>();<br>  &#125;);<br><br>  <span class="hljs-built_in">require</span>.<span class="hljs-title function_">async</span>([<span class="hljs-string">&quot;./c&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params">c, b</span>) &#123;<br>    c.<span class="hljs-title function_">doSomething</span>();<br>    b.<span class="hljs-title function_">doSomething</span>();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>require</code> 是同步往下执行，<code>require.async</code> 则是异步回调执行。<code>require.async</code> 一般用来加载可延迟异步加载的模块。</p><ul><li>获取模块路径<br>require.resolve 使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。</li></ul><p>– <strong><code>exports</code></strong> –</p><p>exports 是一个用来想外接提供模块接口的对象</p><p>提示：exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。</p><p>还有一点就是导出模块不要写在回调函数里，导出是需要同步执行，否则导入是会导入失败。</p><h2 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js 中采用此规范，每一个文件就是一个模块，有自己的作用域，模块中的变量，函数，类都是私有的。</p><p>CommonJS 规范规定，每个模块内部，<code>module</code>变量代表当前模块。这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</p><p>使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模块</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> addX = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> value + x;<br>&#125;;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">x</span> = x;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">addX</span> = addX;<br></code></pre></td></tr></table></figure><p>CommonJS 模块的特点如下：</p><blockquote><p>所有代码都运行在模块作用域，不会污染全局作用域。<br>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>模块加载的顺序，按照其在代码中出现的顺序。</p></blockquote><h3 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h3><p>所有模块都是<code>Module</code>的实例。每个模块内部都有一个 module 对象，代表当前模块。有如下属性：</p><ul><li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li><li><code>module.filename</code> 模块的文件名，带有绝对路径。</li><li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li><li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li><li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li><li><code>module.exports</code> 表示模块对外输出的值。</li></ul><h4 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h4><p><code>module.exports</code>属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取<code>module.exports</code>变量。</p><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>为了方便，Node 为每个模块提供一个<code>exports</code>变量，指向<code>module.exports</code>。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;<br></code></pre></td></tr></table></figure><p>在对外输出模块接口时，可以向 exports 对象添加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&quot;Hello world&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，hello 函数是无法对外输出的，因为 module.exports 被重新赋值了。</p><p>这意味着，<strong>如果一个模块的对外接口，就是一个单一的值，不能使用 exports 输出，只能使用 module.exports 输出</strong>。</p><h3 id="AMD-与-CJS-的兼容性"><a href="#AMD-与-CJS-的兼容性" class="headerlink" title="AMD 与 CJS 的兼容性"></a>AMD 与 CJS 的兼容性</h3><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p><h3 id="require-命令"><a href="#require-命令" class="headerlink" title="require 命令"></a>require 命令</h3><p>模块的循环加载</p><p>如果发生模块的循环加载，即 A 加载 B，B 又加载 A，则 B 将加载 A 的不完整版本。</p><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p><p><strong>require 的内部处理流程</strong></p><p>require 指向当前模块的 module.require，而后者又调用 Node 内部命令 Module._load</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Module</span>.<span class="hljs-property">_load</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">request, parent, isMain</span>) &#123;<br>  <span class="hljs-comment">// 1. 检查Module._cache， 是否缓存中存在此模块</span><br>  <span class="hljs-comment">// 2. 如果缓存中不存在，就创建新的Module实例</span><br>  <span class="hljs-comment">// 3. 添加到缓存</span><br>  <span class="hljs-comment">// 4. 使用module.load()加载指定的模块文件,读取文件之后，使用module.compile()执行文件代码</span><br>  <span class="hljs-comment">// 5. 如果加载/解析报错，就从缓存中删除此模块</span><br>  <span class="hljs-comment">// 6. 返回模块的module.exports</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>通用模块加载规范</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">root, factory</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span> === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;是commonjs模块规范，nodejs环境&quot;</span>);<br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;是AMD模块规范，如require.js&quot;</span>);<br>    <span class="hljs-title function_">define</span>(<span class="hljs-title function_">factory</span>());<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; define.<span class="hljs-property">cmd</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;是CMD模块规范，如sea.js&quot;</span>);<br>    <span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>      <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;没有模块环境，直接挂载在全局对象上&quot;</span>);<br>    root.<span class="hljs-property">umdModule</span> = <span class="hljs-title function_">factory</span>();<br>  &#125;<br>&#125;)(<span class="hljs-variable language_">this</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;我是一个umd模块&quot;</span>,<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><p>ES Modules 特性<br>给 script 标签 设置<code>type = module</code> 来告知当前 script 标签中的代码采用 ESM 的规范来执行</p><ul><li>自动采用严格模式</li><li>每个 ESM 模块都是单独的私有作用域</li><li>ESM 的 script 标签会延迟执行脚本，默认加上了 defer 属性</li><li>ESM 是通过 CORS 这种跨域请求的方式 去请求外部 JS 模块的</li></ul><p><strong>export 导出是栈内存中的变量（原始数据类型存储的是值，对象数据类型存储的是堆内存的引用地址）</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
